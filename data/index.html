<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Alice — v6</title>

  <!--
    CANONICAL AUTH CONTRACT (DO NOT BREAK)

    1) Base API key is CONSTANT, hidden, never entered through the chat UI.
       - Every request MUST include X-API-Key.
       - If missing, UI FAILS CLOSED (no send, no tasks, no unlock).

    2) Admin unlock is conversational PIN only.
       - Admin token is additive (X-ISAC-ADMIN-TOKEN) and session-only.
       - Base key is always sent whether admin is locked or unlocked.

    How the base API key is sourced (in priority order):
      A) <meta name="jarvis-api-key" content="__SET_BASE_API_KEY_HERE__"> (deploy-time injection)
      B) localStorage["jarvis_api_key"] (legacy, no UI prompt; manual only)

    This file intentionally contains NO input field for the base API key.
  -->
  <meta name="jarvis-api-key" content="352400eb0c42ef1e4c14ddcd643f77ebf50da2f394b3ca0707f16018cd884f26" />

  <meta name="theme-color" content="#07080b" />
  <meta name="color-scheme" content="dark light" />

  <!-- Simple inline favicon (no external deps) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' fill='%230b0f14'/%3E%3Ctext x='9' y='23' font-size='18' fill='%23e6eef7' font-family='system-ui, -apple-system, Segoe UI, Roboto, Arial'%3EA%3C/text%3E%3C/svg%3E">

  <style>
    :root{
      --bg:#07080b;
      --bg2:#0b0d12;
      --panel:rgba(18,20,26,.86);
      --panel2:rgba(30,32,40,.92);
      --border:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.66);
      --dim:rgba(255,255,255,.46);
      --warn:rgba(253,224,71,.92);
      --ok:rgba(34,197,94,.90);
      --bad:rgba(248,113,113,.92);
      --shadow:0 20px 60px rgba(0,0,0,.55);
      --r1:22px;
      --r2:16px;
      --font:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      --max:1180px;
    }

    *{box-sizing:border-box}
    html,body{height:100%;min-height:100dvh}
    body{
      margin:0;
      font-family:var(--font);
      color:var(--text);
      background:
        radial-gradient(1100px 800px at 62% 22%, rgba(56,189,248,.08), transparent 55%),
        radial-gradient(900px 700px at 40% 78%, rgba(99,102,241,.06), transparent 60%),
        radial-gradient(900px 700px at 18% 20%, rgba(253,224,71,.05), transparent 62%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      overflow:hidden;
    }

    button,input,textarea{font-family:inherit}
    input,textarea{font-size:16px}
    button{cursor:pointer}

    .app{
      height:100dvh;
      max-width:var(--max);
      margin:0 auto;
      padding:10px;
      padding-bottom:calc(10px + env(safe-area-inset-bottom));
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:10px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border:1px solid var(--border);
      border-radius:var(--r1);
      background:rgba(0,0,0,.22);
      box-shadow:var(--shadow);
      padding:12px;
      min-width:0;
    }
    .brand{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .brand .title{
      font-weight:650;
      letter-spacing:.02em;
      font-size:14px;
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background:rgba(255,255,255,.22);
      box-shadow:0 0 0 4px rgba(255,255,255,.06);
    }
    .brand .subtitle{
      font-size:12px;
      color:var(--dim);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:72ch;
    }
    .chiprow{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .chip{
      border:1px solid rgba(56,189,248,.35);
      background:rgba(56,189,248,.10);
      color:rgba(210,245,255,.95);
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:6px;
      line-height:1;
    }
    .chip.warn{border-color:rgba(253,224,71,.35);background:rgba(253,224,71,.08);color:rgba(255,246,184,.95)}
    .chip.ok{border-color:rgba(34,197,94,.35);background:rgba(34,197,94,.10);color:rgba(195,255,220,.95)}
    .chip.bad{border-color:rgba(248,113,113,.40);background:rgba(248,113,113,.10);color:rgba(255,210,210,.95)}
    .chip.btn{
      cursor:pointer;
      transition:transform .06s ease, background .18s ease;
      border:1px solid rgba(56,189,248,.35);
    }
    .chip.btn:hover{transform:translateY(-1px);background:rgba(56,189,248,.14)}
    .chip.btn:active{transform:translateY(0px)}
    .chip.btn[disabled]{opacity:.45;cursor:not-allowed}

    .kbd{
      font-family:var(--mono);
      font-size:10px;
      padding:2px 6px;
      border:1px solid rgba(255,255,255,.18);
      border-bottom-color:rgba(255,255,255,.10);
      border-radius:8px;
      background:rgba(0,0,0,.25);
      color:rgba(255,255,255,.75);
    }

    .main{
      border:1px solid var(--border);
      border-radius:var(--r1);
      background:rgba(0,0,0,.18);
      box-shadow:var(--shadow);
      overflow:hidden;
      display:flex;
      min-height:0;
      position:relative;
    }
    .conversation{
      flex:1;
      display:flex;
      flex-direction:column;
      min-width:0;
      min-height:0;
    }
    .scroll{
      flex:1;
      overflow:auto;
      padding:14px;
      scroll-behavior:smooth;
    }
    .scroll::-webkit-scrollbar{width:10px}
    .scroll::-webkit-scrollbar-thumb{background:rgba(255,255,255,.10);border-radius:999px}
    .scroll::-webkit-scrollbar-thumb:hover{background:rgba(255,255,255,.14)}

    .msg{
      display:flex;
      gap:10px;
      margin:10px 0;
      align-items:flex-start;
    }
    .avatar{
      flex:0 0 auto;
      width:28px;height:28px;border-radius:12px;
      display:grid;place-items:center;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.82);
      user-select:none;
    }
    .bubble{
      max-width:min(760px, 100%);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:10px 12px;
      background:rgba(16,18,24,.62);
      backdrop-filter: blur(10px);
      box-shadow:0 8px 26px rgba(0,0,0,.25);
      line-height:1.35;
      overflow-wrap:anywhere;
    }
    .msg.me{justify-content:flex-end}
    .msg.me .bubble{
      background:rgba(56,189,248,.10);
      border-color:rgba(56,189,248,.22);
    }
    .msg.me .avatar{display:none}
    .meta{
      margin-top:6px;
      font-size:11px;
      color:var(--dim);
    }
    .bubble pre{
      margin:10px 0 0;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.30);
      font-family:var(--mono);
      font-size:12px;
      overflow:auto;
      max-width:100%;
    }
    .bubble code{font-family:var(--mono);font-size:12px}

    .card{
      margin-top:10px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      background:rgba(0,0,0,.18);
      padding:10px 12px;
    }
    .card h4{
      font-size:12px;
      color:rgba(255,255,255,.80);
      font-weight:650;
      letter-spacing:.02em;
      margin:0 0 8px 0;
      text-transform:uppercase;
    }
    .card .hint{font-size:12px;color:var(--muted);line-height:1.35}
    .card .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-top:10px}

    .btn{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.88);
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
      line-height:1;
      transition:transform .06s ease, background .18s ease, border-color .18s ease;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.08)}
    .btn:active{transform:translateY(0)}
    .btn.primary{border-color:rgba(56,189,248,.30);background:rgba(56,189,248,.12)}
    .btn.danger{border-color:rgba(248,113,113,.38);background:rgba(248,113,113,.12)}
    .btn.ghost{background:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    .composer{
      border:1px solid var(--border);
      border-radius:var(--r1);
      background:rgba(0,0,0,.20);
      box-shadow:var(--shadow);
      padding:10px;
      padding-bottom:calc(10px + env(safe-area-inset-bottom));
      display:flex;
      gap:10px;
      align-items:flex-end;
      min-height:64px;
      position:relative;
    }
    .inputwrap{
      flex:1;
      display:flex;
      align-items:flex-end;
      gap:10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.22);
      border-radius:18px;
      padding:10px 12px;
      min-height:56px;
    }
    textarea{
      width:100%;
      border:none;
      outline:none;
      resize:none;
      background:transparent;
      color:var(--text);
      font-size:16px;
      line-height:1.35;
      min-height:32px;
      max-height:220px;
      -webkit-text-size-adjust:100%;
    }
    textarea::placeholder{color:rgba(255,255,255,.40)}
    .send{
      flex:0 0 auto;
      height:44px;
      min-width:76px;
      padding:0 16px;
      border-radius:14px;
      border:1px solid rgba(56,189,248,.30);
      background:rgba(56,189,248,.14);
      color:rgba(230,250,255,.95);
      font-size:13px;
      line-height:1;
    }
    .send[disabled]{opacity:.45;cursor:not-allowed}

    /* Tasks overlay */
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:stretch;
      justify-content:flex-end;
      z-index:50;
    }
    .overlay.open{display:flex}
    .sheet{
      width:min(520px, 100%);
      height:100%;
      background:var(--panel2);
      border-left:1px solid var(--border);
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
    }
    @media (max-width: 720px){
      .sheet{width:100%; border-left:none;}
    }
    .sheetheader{
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
    }
    .sheetheader .left{display:flex; flex-direction:column; gap:3px; min-width:0;}
    .sheetheader .left strong{font-size:13px; letter-spacing:.02em;}
    .sheetheader .left span{
      font-size:11px; color:var(--dim);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width:54ch;
    }
    .sheetbody{
      flex:1;
      overflow:auto;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .task{
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      background:rgba(0,0,0,.16);
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .task .top{display:flex; align-items:flex-start; justify-content:space-between; gap:10px;}
    .task .name{font-size:13px; font-weight:650; letter-spacing:.01em; line-height:1.25;}
    .task .small{font-size:11px;color:var(--dim); line-height:1.2;}
    .task .status{
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.80);
      white-space:nowrap;
      user-select:none;
    }
    .status.pending{border-color:rgba(253,224,71,.26);background:rgba(253,224,71,.08);color:rgba(255,246,184,.95)}
    .status.running{border-color:rgba(56,189,248,.26);background:rgba(56,189,248,.10);color:rgba(210,245,255,.95)}
    .status.done{border-color:rgba(34,197,94,.28);background:rgba(34,197,94,.10);color:rgba(195,255,220,.95)}
    .status.failed{border-color:rgba(248,113,113,.30);background:rgba(248,113,113,.10);color:rgba(255,210,210,.95)}
    .task .actions{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;}
    .empty{
      border:1px dashed rgba(255,255,255,.18);
      border-radius:16px;
      padding:14px;
      color:var(--muted);
      background:rgba(0,0,0,.12);
      font-size:12px;
      line-height:1.35;
    }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      z-index:70;
      max-width:min(740px, calc(100% - 20px));
      border:1px solid rgba(255,255,255,.14);
      background:rgba(12,14,18,.86);
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:10px 12px;
      box-shadow:var(--shadow);
      display:none;
      gap:10px;
      align-items:flex-start;
    }
    .toast.show{display:flex}
    .toast .t{flex:1; font-size:12px; color:rgba(255,255,255,.86); line-height:1.35;}
    .toast .x{
      border:none;
      background:transparent;
      color:rgba(255,255,255,.70);
      font-size:18px;
      line-height:1;
      padding:0 4px;
      cursor:pointer;
    }

    /* FAIL-CLOSED overlay (base key missing) */
    .fatal{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      background:rgba(0,0,0,.55);
      z-index:40;
    }
    .fatal.show{display:flex}
    .fatalbox{
      width:min(760px, 100%);
      border:1px solid rgba(255,255,255,.16);
      border-radius:18px;
      background:rgba(12,14,18,.90);
      box-shadow:var(--shadow);
      padding:14px 14px 12px;
    }
    .fatalbox h3{
      margin:0 0 8px 0;
      font-size:13px;
      letter-spacing:.02em;
      text-transform:uppercase;
      color:rgba(255,246,184,.95);
    }
    .fatalbox p{
      margin:0 0 10px 0;
      font-size:13px;
      line-height:1.35;
      color:rgba(255,255,255,.86);
    }
    .fatalbox .small{
      font-size:12px;
      color:rgba(255,255,255,.66);
      line-height:1.35;
      font-family:var(--mono);
      white-space:pre-wrap;
      user-select:text;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.25);
      border-radius:14px;
      padding:10px 12px;
    }

    :focus-visible{
      outline:2px solid rgba(56,189,248,.55);
      outline-offset:2px;
      border-radius:12px;
    }

    /* System (non-conversational) messages: never Alice voice */
    .msg.system{justify-content:flex-start}
    .msg.system .avatar{
      background:rgba(255,255,255,.04);
      border-color:rgba(255,255,255,.10);
      color:rgba(255,255,255,.55);
    }
    .msg.system .bubble{
      background:rgba(255,255,255,.04);
      border-color:rgba(255,255,255,.10);
      color:rgba(255,255,255,.80);
    }
    .msg.system .meta{color:rgba(255,255,255,.38)}
  </style>
</head>

<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="title"><span class="dot" id="healthDot"></span> Alice</div>
        <div class="subtitle" id="subtitle">Conversation-first. Tasks only appear when you ask.</div>
      </div>

      <div class="chiprow">
        <div class="chip" id="healthChip">Backend: unknown</div>

        <button class="chip btn" id="tasksChip" type="button" title="Show tasks (or type: show tasks)">
          Tasks <span id="tasksCount" class="kbd">0</span>
        </button>

        <button class="chip btn warn" id="adminChip" type="button" title="Unlock admin (or type: unlock admin)">
          Admin <span id="adminState" class="kbd">locked</span>
        </button>
      </div>
    </header>

    <main class="main">
      <section class="conversation" aria-label="Conversation">
        <div class="scroll" id="scroll">
          <div id="messages"></div>
        </div>
      </section>

      <!-- Fail-closed overlay when base API key is missing -->
      <div class="fatal" id="fatalOverlay" role="alert" aria-live="assertive">
        <div class="fatalbox">
          <h3>Base API key missing (fail-closed)</h3>
          <p>
            Alice cannot send any requests without the constant base API key.
            This key is never entered through chat. Provide it via deploy-time meta tag
            or legacy localStorage.
          </p>
          <div class="small" id="fatalDetails"></div>
        </div>
      </div>
    </main>

    <footer class="composer" aria-label="Message composer">
      <div class="inputwrap">
        <textarea id="input" rows="1" placeholder="Message Alice…"></textarea>
        <button class="send" id="sendBtn" type="button">Send</button>
      </div>
    </footer>
  </div>

  <div class="overlay" id="tasksOverlay" role="dialog" aria-modal="true" aria-label="Tasks">
    <div class="sheet" role="document">
      <div class="sheetheader">
        <div class="left">
          <strong>Tasks</strong>
          <span id="tasksSubtitle">Loaded on request. No background polling.</span>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button class="btn" id="refreshTasksBtn" type="button">Refresh</button>
          <button class="btn ghost" id="closeTasksBtn" type="button">Close</button>
        </div>
      </div>
      <div class="sheetbody" id="tasksBody">
        <div class="empty">Say “show tasks” to open this panel. Tasks do not compete with conversation for authority.</div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite">
    <div class="t" id="toastText"></div>
    <button class="x" id="toastClose" type="button" aria-label="Close">×</button>
  </div>

    <script>
(() => {
  'use strict';

  // ---------- DOM ----------
  const $ = (sel) => document.querySelector(sel);
  const els = {};

  function bindEls() {
    els.healthDot   = $('#healthDot');
    els.healthChip  = $('#healthChip');
    els.tasksChip   = $('#tasksChip');
    els.tasksCount  = $('#tasksCount');
    els.adminChip   = $('#adminChip');
    els.adminState  = $('#adminState');

    els.scroll      = $('#scroll');
    els.messages    = $('#messages');

    els.input       = $('#input');
    els.sendBtn     = $('#sendBtn');

    els.tasksOverlay     = $('#tasksOverlay');
    els.tasksBody        = $('#tasksBody');
    els.refreshTasksBtn  = $('#refreshTasksBtn');
    els.closeTasksBtn    = $('#closeTasksBtn');

    els.toast       = $('#toast');
    els.toastText   = $('#toastText');
    els.toastClose  = $('#toastClose');

    els.fatalOverlay = $('#fatalOverlay');
    els.fatalDetails = $('#fatalDetails');

    els.subtitle = $('#subtitle');
  }

  // ---------- API ----------
  const API = {
    health: '/health',
    ask: '/ask',
    gateAdvance: '/alice/gate/advance',
    adminUnlock: '/auth/admin/unlock',
    tasksList: '/tasks',
    taskGet: (id) => `/tasks/${id}`,
    taskResume: (id) => `/tasks/${id}/resume`,
    taskAbort: (id) => `/tasks/${id}/abort`,

    memoryCandidates: {
      concepts: [
        '/alice/memory/concepts',
        '/memory/concepts',
        '/alice/memory/concept',
        '/memory/concept',
      ],
    },
  };

  // ---------- State ----------
  const state = {
    apiKey: null,            // REQUIRED for every request (constant; never entered via UI)
    adminToken: null,        // session-only
    adminUnlocked: false,
    backendOk: null,

    tasksOpen: false,
    tasks: [],

    // Memory mediation state (UI-side; prevents "yes-to-what?" loops)
    pendingMemory: null,     // { kind:'write'|'delete', key:'...' }

    memoryEndpoints: {
      conceptsBase: null,    // resolved GET/POST endpoint for concepts list/create
    },

    // UI arbiter state (non-conversational)
    lastDecision: null,      // 'RESTRAIN'|'CLARIFY'|'ADVANCE_OK'|null

    // Restraint whisper throttling (prevents spam, keeps it human)
    restrain: { lastAt: 0, lastReason: '', streak: 0 },
  };

  // ---------- Utilities ----------
  const esc = (s) => String(s ?? '')
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');

  function nowTime() {
    try { return new Date().toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' }); }
    catch { return ''; }
  }

  function toast(msg) {
    if (!els.toast || !els.toastText) return;
    els.toastText.textContent = msg;
    els.toast.classList.add('show');
    setTimeout(() => els.toast?.classList.remove('show'), 3500);
  }

  function setSubtitle(text) {
    if (!els.subtitle) return;
    els.subtitle.textContent = text;
  }

  function setHealth(ok) {
    state.backendOk = ok;
    if (!els.healthChip || !els.healthDot) return;

    els.healthChip.classList.remove('ok','bad');
    els.healthDot.style.background = 'rgba(255,255,255,.22)';

    if (ok === true) {
      els.healthChip.textContent = 'Backend: ok';
      els.healthChip.classList.add('ok');
      els.healthDot.style.background = 'rgba(34,197,94,.90)';
    } else if (ok === false) {
      els.healthChip.textContent = 'Backend: down';
      els.healthChip.classList.add('bad');
      els.healthDot.style.background = 'rgba(248,113,113,.92)';
    } else {
      els.healthChip.textContent = 'Backend: unknown';
    }
  }

  function setAdminUI() {
    if (!els.adminState || !els.adminChip) return;
    els.adminState.textContent = state.adminUnlocked ? 'unlocked' : 'locked';
    els.adminChip.classList.toggle('ok', !!state.adminUnlocked);
    els.adminChip.classList.toggle('warn', !state.adminUnlocked);
  }

  function setTasksCount(n) {
    if (els.tasksCount) els.tasksCount.textContent = String(n ?? 0);
  }

  function scrollToBottom() {
    if (!els.scroll) return;
    els.scroll.scrollTop = els.scroll.scrollHeight;
  }

  // ---------- Transcript (session-only) ----------
  const CHAT_STORAGE = {
    id: 'alice_chat_id_v1',
    messages: 'alice_chat_messages_v1'
  };

  function uuidv4() {
    try { return crypto.randomUUID(); }
    catch { return 'chat_' + Math.random().toString(16).slice(2) + Date.now().toString(16); }
  }

  function loadChatFromSession() {
    let chatId = null;
    let msgs = [];
    try { chatId = sessionStorage.getItem(CHAT_STORAGE.id); } catch {}
    try {
      const raw = sessionStorage.getItem(CHAT_STORAGE.messages);
      if (raw) msgs = JSON.parse(raw) || [];
    } catch {}

    if (!chatId) {
      chatId = uuidv4();
      msgs = [];
      try { sessionStorage.setItem(CHAT_STORAGE.id, chatId); } catch {}
      try { sessionStorage.setItem(CHAT_STORAGE.messages, JSON.stringify(msgs)); } catch {}
    }

    state.chat = { id: chatId, messages: Array.isArray(msgs) ? msgs : [] };
  }

  function persistChatToSession() {
    if (!state.chat) return;
    try { sessionStorage.setItem(CHAT_STORAGE.id, state.chat.id); } catch {}
    try { sessionStorage.setItem(CHAT_STORAGE.messages, JSON.stringify(state.chat.messages || [])); } catch {}
  }

  function clearChatSession() {
    try { sessionStorage.removeItem(CHAT_STORAGE.id); } catch {}
    try { sessionStorage.removeItem(CHAT_STORAGE.messages); } catch {}
    state.chat = { id: uuidv4(), messages: [] };
    persistChatToSession();
  }

  function appendMessage(role, text) {
    if (!state.chat) loadChatFromSession();
    const msg = {
      id: uuidv4(),
      role,                // 'me' | 'alice' | 'system'
      text: String(text ?? ''),
      ts: Date.now(),
      kind: 'bubble'
    };
    state.chat.messages.push(msg);
    const MAX = 200;
    if (state.chat.messages.length > MAX) state.chat.messages = state.chat.messages.slice(-MAX);
    persistChatToSession();
  }

  // ---------- Bubbles ----------
  function addBubble(role, html) {
    if (!els.messages) return;

    const row = document.createElement('div');
    row.className = `msg ${role === 'me' ? 'me' : role === 'system' ? 'system' : ''}`;

    if (role !== 'me') {
      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.textContent = (role === 'system') ? '•' : 'A';
      row.appendChild(avatar);
    }

    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    bubble.innerHTML = html;

    row.appendChild(bubble);

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = nowTime();
    bubble.appendChild(meta);

    els.messages.appendChild(row);
    scrollToBottom();
  }

  function sayMe(text) {
    const t = String(text ?? '');
    addBubble('me', `<div>${esc(t)}</div>`);
    appendMessage('me', t);
  }

  // NOTE: Alice speech is ONLY allowed via the Response Arbiter.
  function sayAliceSpeech(text) {
    const t = String(text ?? '');
    addBubble('alice', `<div>${esc(t)}</div>`);
    appendMessage('alice', t);
  }

  // System (non-conversational) note: factual, brief, never Alice voice
  function systemNote(text) {
    const t = String(text ?? '');
    addBubble('system', `<div>${esc(t)}</div>`);
    appendMessage('system', t);
  }

  function systemCard(title, bodyHtml) {
    const ttl = String(title ?? '').trim();
    const html = `<div class="card"><h4>${esc(ttl)}</h4>${bodyHtml || ''}</div>`;
    addBubble('system', html);
    appendMessage('system', `${ttl}`);
  }

  function renderTranscriptFromState() {
    if (!els.messages) return;
    els.messages.innerHTML = '';
    const msgs = state.chat?.messages || [];
    for (const m of msgs) {
      addBubble(m.role === 'me' ? 'me' : (m.role === 'system' ? 'system' : 'alice'), `<div>${esc(m.text)}</div>`);
    }
    scrollToBottom();
  }

  function buildContextBlockForModel(opts) {
    const excludeLast = opts?.excludeLast ?? false;
    let msgs = (state.chat?.messages || []).filter(m => m.role !== 'system');
    if (excludeLast && msgs.length) msgs = msgs.slice(0, -1);
    if (!msgs.length) return '';
    const slice = msgs.slice(-24);
    let out = 'Conversation so far (most recent last):\n';
    for (const m of slice) {
      const who = (m.role === 'me') ? 'User' : 'Alice';
      const line = String(m.text || '').trim();
      if (!line) continue;
      out += `${who}: ${line}\n`;
      if (out.length > 3500) break;
    }
    return out.trim();
  }



  // Build structured context for the legitimacy gate.
  // The gate expects an array like: [{role:"user"|"assistant", content:"..."}]
  function buildCtxArrayForGate(opts) {
    const excludeLast = opts?.excludeLast ?? false;
    let msgs = (state.chat?.messages || []).filter(m => m.role !== 'system');
    if (excludeLast && msgs.length) msgs = msgs.slice(0, -1);
    if (!msgs.length) return [];
    const slice = msgs.slice(-24);
    return slice
      .map(m => {
        const role = (m.role === 'me') ? 'user' : 'assistant';
        const content = String(m.text || '').trim();
        return { role, content };
      })
      .filter(m => m.content);
  }
  // ---------- Fail-closed behavior ----------
  function setFailClosed(on, details) {
    const disabled = !!on;

    if (els.fatalOverlay) els.fatalOverlay.classList.toggle('show', disabled);
    if (els.fatalDetails) els.fatalDetails.textContent = details || '';

    if (els.sendBtn) els.sendBtn.disabled = disabled;
    if (els.input) els.input.disabled = disabled;
    if (els.tasksChip) els.tasksChip.disabled = disabled;
    if (els.adminChip) els.adminChip.disabled = disabled;

    if (disabled) {
      setHealth(null);
      setTasksCount(0);
      setAdminUI();
    }
  }

  function readMetaBaseKey() {
    const el = document.querySelector('meta[name="jarvis-api-key"]');
    const v = (el?.getAttribute('content') || '').trim();
    if (!v) return null;
    if (v === '__SET_BASE_API_KEY_HERE__') return null;
    return v;
  }

  function loadAuth() {
    state.apiKey = readMetaBaseKey();
    if (!state.apiKey) {
      try {
        const k = localStorage.getItem('jarvis_api_key');
        if (k && String(k).trim()) state.apiKey = String(k).trim();
      } catch {}
    }

    state.adminToken = null;
    state.adminUnlocked = false;
    try { sessionStorage.removeItem('isac_admin_token'); } catch {}
    setAdminUI();

    if (!state.apiKey) {
      const help =
        "To set legacy localStorage (manual, outside UI):\n" +
        "  localStorage.setItem('jarvis_api_key', 'YOUR_BASE_KEY');\n" +
        "  location.reload();\n\n" +
        "Preferred: inject base key via <meta name=\"jarvis-api-key\"> at deploy time.";
      setFailClosed(true, help);
      return false;
    }

    setFailClosed(false, '');
    return true;
  }

  // ---------- Request wrapper ----------
  function buildHeaders(extra) {
    if (!state.apiKey) throw new Error('Base API key missing');

    const h = { 'Content-Type': 'application/json', 'X-API-Key': state.apiKey };

    if (state.adminUnlocked) {
      h['X-ISAC-ADMIN-KEY'] = state.apiKey;
      if (state.adminToken) h['X-ISAC-ADMIN-TOKEN'] = state.adminToken;
    }

    return { ...h, ...(extra || {}) };
  }

  function stringifyDetail(x) {
    if (x == null) return '';
    if (typeof x === 'string') return x;
    try { return JSON.stringify(x); } catch { return String(x); }
  }


  function firstQuestionOnly(q) {
    const s = String(q || '').trim();
    if (!s) return '';
    // If multiple questions appear, keep only the first one (tight CLARIFY contract).
    const qm = s.indexOf('?');
    if (qm !== -1) return (s.slice(0, qm + 1)).trim();
    // Otherwise keep just the first line.
    return s.split('\n').map(x => x.trim()).filter(Boolean)[0] || s;
  }

  function restraintWhisper(reason) {
    const now = Date.now();
    const r = String(reason || '').trim();
    const same = (r && r === state.restrain.lastReason);
    const within = (now - (state.restrain.lastAt || 0)) < 2500;

    // Presence cue only. Never instruct wake words. Never auto-advance.
    // Throttle repeats so we don't spam "Listening." on rapid retries.
    if (within && same) {
      state.restrain.streak = (state.restrain.streak || 1) + 1;
      return null;
    }

    state.restrain.streak = 1;
    state.restrain.lastReason = r || null;
    state.restrain.lastAt = now;
    return 'Listening.';
  }
  async function fetchJson(url, opts = {}) {
    const res = await fetch(url, {
      method: opts.method || 'GET',
      headers: buildHeaders(opts.headers),
      body: opts.body,
    });

    const ct = (res.headers.get('content-type') || '').toLowerCase();
    let data;
    if (ct.includes('application/json')) data = await res.json().catch(() => ({}));
    else data = { detail: (await res.text().catch(() => '')).slice(0, 1200) };

    if (!res.ok) {
      const msg = stringifyDetail(data?.detail) || stringifyDetail(data?.message) || `HTTP ${res.status}`;
      const err = new Error(msg);
      err.status = res.status;
      err.data = data;
      throw err;
    }
    return data;
  }

  // ---------- Health ----------
  async function checkHealth() {
    try {
      await fetchJson(API.health, { method: 'GET' });
      setHealth(true);
    } catch {
      setHealth(false);
    }
  }

  // ---------- Admin unlock (system UI only) ----------
  function showUnlockCard() {
    if (!state.apiKey) return;

    systemCard('PLAN · Conversational admin unlock', `
      <div class="hint">
        Enter your admin PIN to unlock this session. PIN is never stored. Token is session-only.
      </div>
      <div class="row">
        <input id="pinInput" type="password" placeholder="PIN"
          style="flex:1; padding:10px; border-radius:12px; border:1px solid rgba(255,255,255,.18); background:rgba(0,0,0,.25); color:rgba(255,255,255,.9);" />
        <button id="pinUnlock" class="btn primary" type="button">Unlock</button>
        <button id="pinCancel" class="btn" type="button">Cancel</button>
      </div>
    `);

    setTimeout(() => {
      const inp = $('#pinInput');
      const ok = $('#pinUnlock');
      const cancel = $('#pinCancel');
      if (!inp || !ok || !cancel) return;

      const doUnlock = async () => {
        const pin = String(inp.value || '').trim();
        if (!pin) { toast('PIN required.'); return; }
        try {
          const data = await fetchJson(API.adminUnlock, { method:'POST', body: JSON.stringify({ pin }) });
          const tok = String(data?.admin_token || data?.token || '').trim();
          if (!tok) throw new Error('Unlock returned no token');

          state.adminToken = tok;
          state.adminUnlocked = true;
          try { sessionStorage.setItem('isac_admin_token', tok); } catch {}
          setAdminUI();
          toast('Admin unlocked.');
        } catch (e) {
          state.adminToken = null;
          state.adminUnlocked = false;
          try { sessionStorage.removeItem('isac_admin_token'); } catch {}
          setAdminUI();
          toast(`Admin unlock failed (${e.status || 'ERR'}).`);
        }
      };

      ok.addEventListener('click', () => void doUnlock());
      inp.addEventListener('keydown', (e) => { if (e.key === 'Enter') void doUnlock(); });
      cancel.addEventListener('click', () => toast('Cancelled.'));
      inp.focus();
    }, 0);
  }

  function lockAdmin() {
    state.adminToken = null;
    state.adminUnlocked = false;
    state.pendingMemory = null;
    try { sessionStorage.removeItem('isac_admin_token'); } catch {}
    setAdminUI();
    toast('Admin locked.');
  }

  // ---------- Tasks overlay ----------
  function openTasks() {
    state.tasksOpen = true;
    if (els.tasksOverlay) els.tasksOverlay.classList.add('open');
    void loadTasks();
  }
  function closeTasks() {
    state.tasksOpen = false;
    if (els.tasksOverlay) els.tasksOverlay.classList.remove('open');
  }

  function renderTasks() {
    if (!els.tasksBody) return;

    const tasks = state.tasks || [];
    setTasksCount(tasks.length);

    if (!tasks.length) {
      els.tasksBody.innerHTML = `<div class="empty">No tasks found.</div>`;
      return;
    }

    els.tasksBody.innerHTML = '';
    for (const t of tasks) {
      const div = document.createElement('div');
      div.className = 'task';

      const status = String(t.status || 'unknown').toLowerCase();
      const statusClass = status.includes('complete') ? 'done'
        : status.includes('fail') ? 'failed'
        : status.includes('run') ? 'running'
        : 'pending';

      div.innerHTML = `
        <div class="top">
          <div>
            <div class="name">${esc(t.title || '(untitled)')}</div>
            <div class="small">ID: ${esc(t.id)}${t.resume_hint ? ' · ' + esc(t.resume_hint) : ''}</div>
          </div>
          <div class="status ${statusClass}">${esc(status)}</div>
        </div>
        <div class="actions">
          <button class="btn" data-act="details" data-id="${esc(t.id)}">Details</button>
          <button class="btn primary" data-act="resume" data-id="${esc(t.id)}">Resume</button>
          <button class="btn danger" data-act="abort" data-id="${esc(t.id)}">Abort</button>
        </div>
      `;
      els.tasksBody.appendChild(div);
    }

    els.tasksBody.querySelectorAll('button[data-act]').forEach(btn => {
      btn.addEventListener('click', () => {
        const act = btn.getAttribute('data-act');
        const id = btn.getAttribute('data-id');
        if (!id) return;
        if (act === 'details') void taskDetails(id);
        if (act === 'resume') void taskResume(id);
        if (act === 'abort') void taskAbort(id);
      });
    });
  }

  async function loadTasks() {
    try {
      const data = await fetchJson(API.tasksList, { method:'GET' });
      state.tasks = Array.isArray(data?.tasks) ? data.tasks : (Array.isArray(data) ? data : []);
      renderTasks();
    } catch (e) {
      toast(`Tasks load failed (${e.status || 'ERR'}).`);
    }
  }

  async function taskDetails(id) {
    try {
      const data = await fetchJson(API.taskGet(id), { method:'GET' });
      systemCard('RESULT · Task details', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
    } catch (e) {
      toast(`Details failed (${e.status || 'ERR'}).`);
    }
  }

  async function taskResume(id) {
    if (!state.adminUnlocked) { toast('Admin locked. Type: unlock admin'); return; }
    try {
      const data = await fetchJson(API.taskResume(id), { method:'POST', body:'{}' });
      systemCard('RESULT · Resume', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
      await loadTasks();
    } catch (e) {
      toast(`Resume failed (${e.status || 'ERR'}).`);
    }
  }

  async function taskAbort(id) {
    if (!state.adminUnlocked) { toast('Admin locked. Type: unlock admin'); return; }
    try {
      const data = await fetchJson(API.taskAbort(id), { method:'POST', body:'{}' });
      systemCard('RESULT · Abort', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
      await loadTasks();
    } catch (e) {
      toast(`Abort failed (${e.status || 'ERR'}).`);
    }
  }

  // ---------- Memory (system UI only) ----------
  async function resolveConceptsBase() {
    if (state.memoryEndpoints.conceptsBase) return state.memoryEndpoints.conceptsBase;

    for (const url of API.memoryCandidates.concepts) {
      try {
        const res = await fetch(url, { method:'GET', headers: buildHeaders() });
        if (res.status === 404) continue;
        if ([200, 401, 403, 405].includes(res.status)) {
          state.memoryEndpoints.conceptsBase = url;
          return url;
        }
      } catch {}
    }
    throw new Error('Memory concepts endpoint not found');
  }

  function normalizeConceptKey(s) {
    return String(s || '').trim().replace(/^["“”']|["“”']$/g, '').trim();
  }

  function makeConceptPayload(conceptKey) {
    return { concept_key: conceptKey, notes: 'memory test concept', confidence: 1.0 };
  }

  async function memoryWriteConcept(conceptKey) {
    if (!state.adminUnlocked) throw new Error('Admin is locked');
    const base = await resolveConceptsBase();
    const clean = normalizeConceptKey(conceptKey);
    if (!clean) throw new Error('Concept key required');
    return await fetchJson(base, { method:'POST', body: JSON.stringify(makeConceptPayload(clean)) });
  }

  async function memoryFetchConceptObjects() {
    const base = await resolveConceptsBase();
    const data = await fetchJson(base, { method: 'GET' });

    const arr =
      Array.isArray(data) ? data :
      Array.isArray(data?.concepts) ? data.concepts :
      Array.isArray(data?.items) ? data.items :
      [];

    return arr;
  }

  async function memoryListConcepts() {
    const arr = await memoryFetchConceptObjects();
    return arr.map(x => {
      if (typeof x === 'string') return x;
      return x?.concept_key || x?.key || x?.concept || x?.name || JSON.stringify(x);
    });
  }

  async function memoryDeleteConcept(conceptKey) {
    if (!state.adminUnlocked) throw new Error('Admin is locked');
    const clean = normalizeConceptKey(conceptKey);
    if (!clean) throw new Error('Concept key required');

    const base = (await resolveConceptsBase()).replace(/\/$/, '');
    const arr = await memoryFetchConceptObjects();
    const hit = arr.find(x => x && typeof x === 'object' && String(x.concept_key || x.key || '').trim() === clean);
    if (!hit) return { ok: true, already_deleted: true };

    const id = hit.id ?? hit.concept_id ?? hit.pk;
    if (id == null) throw new Error('Memory item missing id');

    const url = `${base}/${encodeURIComponent(String(id))}`;
    return await fetchJson(url, { method: 'DELETE' });
  }

  function isAffirmation(text) {
    const t = String(text || '').trim().toLowerCase();
    return ['yes','y','yep','yeah','ok','okay','confirm','do it','sure','affirmative','proceed'].includes(t);
  }
  function isNegation(text) {
    const t = String(text || '').trim().toLowerCase();
    return ['no','n','nope','nah','cancel','stop','never mind','nevermind','forget it','dont','don’t'].includes(t);
  }

  function setPending(kind, key) {
    state.pendingMemory = { kind, key: normalizeConceptKey(key) };
    if (state.pendingMemory.key) toast(`Pending ${kind}: ${state.pendingMemory.key} (reply “yes” to confirm)`);
  }
  function clearPending() { state.pendingMemory = null; }

  async function handlePendingConfirmation(userText) {
    if (!state.pendingMemory) return false;

    if (isNegation(userText)) {
      toast('Cancelled.');
      clearPending();
      return true;
    }

    if (!isAffirmation(userText)) {
      toast('Pending confirmation. Reply “yes” to confirm or “no” to cancel.');
      return true;
    }

    const { kind, key } = state.pendingMemory;
    clearPending();

    try {
      if (kind === 'write') {
        await memoryWriteConcept(key);
        toast('Memory write complete.');
      } else if (kind === 'delete') {
        await memoryDeleteConcept(key);
        toast('Memory delete complete.');
      } else {
        throw new Error('Unknown pending action');
      }
    } catch (e) {
      toast(`Memory action failed (${e.status || 'ERR'}).`);
    }

    return true;
  }

  // ---------- Response Arbiter ----------
  function normalizeDecisionObject(data) {
    if (!data || typeof data !== 'object') {
      return { decision: 'ADVANCE_OK', text: String(data ?? '') };
    }

    const decision = String(data.decision || data.outcome || data.gate || '').toUpperCase().trim();

    if (decision === 'RESTRAIN') return { decision: 'RESTRAIN' };

    if (decision === 'CLARIFY') {
        // Exactly one question bubble, no extra commentary. If multiple questions arrive, keep only the first.
        let q = String(gate?.question || '').trim();
        q = firstQuestionOnly(q);

        // If the gate didn't supply a question, fall back to a single, minimal prompt.
        if (!q) q = 'What would you like me to do with that?';
        setSubtitle('Alice asked a clarification.');
        sayAliceSpeech(q);
        return;
      }

    setSubtitle('Conversation-first. Tasks only appear when you ask.');
    sayAliceSpeech(d.text || '(no reply)');
  }

  // ---------- /ask ----------
  const ALICE_SYSTEM_PROMPT = [
    "You are Alice, the sole human-facing assistant.",
    "ISAC is the silent backend. Never mention ISAC, never identify as ISAC, and never say you are ISAC.",
    "Conversation is the authority spine. Be concise, clear, and practical.",
    "If a user asks you to remember something, ask for explicit confirmation before any memory write.",
    "If you cannot perform an action, explain why and suggest the next safe step."
  ].join("\n");

  async function sendAsk(text) {
    try {
      const raw = String(text || '').trim();
      if (!raw) return;

      // 1) Legitimacy gate (v2): decide whether Alice may speak.
      const gateCtx = buildCtxArrayForGate({ excludeLast: true });
      // Backend owns semantic intent. No wake words, no name-prefix requirements.
      const gatePayload = {
        msg: raw,
        ctx: gateCtx,
        mode: 'normal',
        flags: {}
};

      const gate = await fetchJson(API.gateAdvance, { method:'POST', body: JSON.stringify(gatePayload) });
      const decision = String(gate?.decision || '').toUpperCase().trim();
      state.lastDecision = decision || null;

      if (decision === 'RESTRAIN') {
        // Silence: no Alice bubble. A single, throttled system whisper keeps it human without being chatty.
        setSubtitle('Listening.');

        const why = Array.isArray(gate?.reasons) ? gate.reasons.join(', ') : '';
        const whisper = restraintWhisper(why);
        if (whisper) systemNote(whisper);

        // Deliberately do NOT print raw gate reasons into the chat.
        return;
      }

      if (decision === 'CLARIFY') {
        // Exactly one question bubble, no extra commentary.
        const q = String(gate?.question || '').trim();
        setSubtitle('Alice asked a clarification.');
        if (q) sayAliceSpeech(q);
        else systemNote('Clarification requested.');
        return;
      }

      // 2) ADVANCE_OK: ask the model for a normal reply.
      const ctx = buildContextBlockForModel({ excludeLast: true });
      const composed = ctx ? (ctx + "\n\nUser: " + raw) : raw;
      const payload = { message: composed, system_prompt: ALICE_SYSTEM_PROMPT };

      ASK_ALLOWED = true;
      let data;
      try {
        data = await askModel(API.ask, { method:'POST', body: JSON.stringify(payload) });
      } finally {
        ASK_ALLOWED = false;
      }

      const replyText = String(data?.reply || data?.answer || data?.response || data?.text || '');
      const leak = /\b(i\s*['’]?m|i\s*am)\s+isac\b/i.test(replyText) || /\bisac\b\s*(brain|backend)/i.test(replyText);
      if (leak) {
        systemNote('Response blocked (identity boundary).');
        return;
      }

      setSubtitle('Conversation-first. Tasks only appear when you ask.');
      sayAliceSpeech(String(replyText || '(no reply)').trim());

      // Memory suggestion hooks (system-only confirmation loop)
      const m1 = replyText.match(/remember\s*[“"']([^”"']+)[”"']/i);
      if (m1?.[1]) setPending('write', m1[1]);

      const f1 = replyText.match(/forget\s*[“"']([^”"']+)[”"']/i);
      if (f1?.[1]) setPending('delete', f1[1]);

    } catch (e) {
      const code = e.status ? `HTTP ${e.status}` : 'ERR';
      systemNote(`Request failed (${code}).`);
      systemCard('ERROR · Request failed', `<pre>${esc(String(e.message || 'Unknown error').slice(0, 1200))}</pre>`);
      setHealth(false);
    }
  }

  // ---------- Command routing ----------
  async function handle(text) {
    const t = String(text || '').trim();
    const c = t.toLowerCase();

    if (state.pendingMemory) {
      const consumed = await handlePendingConfirmation(t);
      if (consumed) return;
    }

    if (c === 'show tasks' || c === 'tasks') { openTasks(); return; }
    if (c === 'unlock admin' || c === 'unlock') { showUnlockCard(); return; }
    if (c === 'lock admin' || c === 'lock') { lockAdmin(); return; }
    if (/^start over\b/i.test(t) || c === 'reset chat') {
      systemNote('Chat cleared for this session on this device.');
      clearChatSession();
      if (els.messages) els.messages.innerHTML = '';
      toast('Chat cleared.');
      return;
    }

    if (/^(list|show)\s+mem(ory|ories)\b/i.test(t) || /^what (memories|memory) do you have\b/i.test(c)) {
      try {
        const items = await memoryListConcepts();
        if (!items.length) systemNote('Memory is currently empty.');
        else systemCard('RESULT · Memories', `<pre>${esc(JSON.stringify(items, null, 2))}</pre>`);
      } catch (e) {
        toast(`Memory read failed (${e.status || 'ERR'}).`);
      }
      return;
    }

    const forgetMatch = t.match(/^(forget|delete)\s+(.+)$/i);
    if (forgetMatch) {
      const key = normalizeConceptKey(forgetMatch[2]);
      if (!key) { toast('Forget what? Provide a key.'); return; }
      if (!state.adminUnlocked) { toast('Admin locked. Type: unlock admin'); return; }
      setPending('delete', key);
      toast('Pending delete. Reply “yes” to confirm.');
      return;
    }

    await sendAsk(t);
  }

  // ---------- Input ----------
  function autosize() {
    if (!els.input) return;
    els.input.style.height = 'auto';
    els.input.style.height = Math.min(220, els.input.scrollHeight) + 'px';
  }

  function onSend() {
    const text = String(els.input?.value || '').trim();
    if (!text) return;
    els.input.value = '';
    autosize();
    sayMe(text);
    void handle(text);
  }

  // ---------- Boot ----------
  function boot() {
    bindEls();

    if (!els.scroll || !els.messages || !els.input || !els.sendBtn) {
      console.error('DOM missing required nodes. Expected #scroll, #messages, #input, #sendBtn');
      return;
    }

    const ok = loadAuth();
    setTasksCount(0);
    setAdminUI();

    loadChatFromSession();
    renderTranscriptFromState();

    if ((state.chat?.messages || []).length === 0) {
      systemNote('Ready.');
    }

    els.sendBtn.addEventListener('click', onSend);
    els.input.addEventListener('input', autosize);
    els.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        onSend();
      }
    });

    els.tasksChip?.addEventListener('click', () => state.tasksOpen ? closeTasks() : openTasks());
    els.adminChip?.addEventListener('click', () => state.adminUnlocked ? lockAdmin() : showUnlockCard());

    els.closeTasksBtn?.addEventListener('click', closeTasks);
    els.refreshTasksBtn?.addEventListener('click', () => void loadTasks());
    els.tasksOverlay?.addEventListener('click', (e) => { if (e.target === els.tasksOverlay) closeTasks(); });

    els.toastClose?.addEventListener('click', () => els.toast?.classList.remove('show'));

    autosize();
    if (ok) void checkHealth();
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();

  // Guard against any accidental /ask bypass paths.
  // Only sendAsk() is allowed to call /ask, and only after the gate returns ADVANCE_OK.
  let ASK_ALLOWED = false;

  async function askModel(url, opts) {
    if (!ASK_ALLOWED) {
      const err = new Error('ASK_BYPASS_BLOCKED');
      err.status = 499;
      throw err;
    }
    return await fetchJson(url, opts);
  }
})();
  </script>
</body>
</html>