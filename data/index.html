<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Alice — v6 (v3 Presence Grammar)</title>

  <!--
    CANONICAL AUTH CONTRACT (DO NOT BREAK)

    1) Base API key is CONSTANT, hidden, never entered through the chat UI.
       - Every request MUST include X-API-Key.
       - If missing, UI FAILS CLOSED (no send, no tasks, no unlock).

    2) Admin unlock is conversational PIN only.
       - Admin token is additive (X-ISAC-ADMIN-TOKEN) and session-only.
       - Base key is always sent whether admin is locked or unlocked.

    How the base API key is sourced (in priority order):
      A) <meta name="jarvis-api-key" content="__SET_BASE_API_KEY_HERE__"> (deploy-time injection)
      B) localStorage["jarvis_api_key"] (legacy, no UI prompt; manual only)

    This file intentionally contains NO input field for the base API key.
  -->
  <meta name="jarvis-api-key" content="352400eb0c42ef1e4c14ddcd643f77ebf50da2f394b3ca0707f16018cd884f26" />

  <meta name="theme-color" content="#07080b" />
  <meta name="color-scheme" content="dark light" />

  <!-- Simple inline favicon (no external deps) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect width='32' height='32' fill='%230b0f14'/%3E%3Ctext x='9' y='23' font-size='18' fill='%23e6eef7' font-family='system-ui, -apple-system, Segoe UI, Roboto, Arial'%3EA%3C/text%3E%3C/svg%3E">

  <style>
    :root{
      --bg:#07080b;
      --bg2:#0b0d12;
      --panel:rgba(18,20,26,.86);
      --panel2:rgba(30,32,40,.92);
      --border:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.66);
      --dim:rgba(255,255,255,.46);
      --warn:rgba(253,224,71,.92);
      --ok:rgba(34,197,94,.90);
      --bad:rgba(248,113,113,.92);
      --shadow:0 20px 60px rgba(0,0,0,.55);
      --r1:22px;
      --r2:16px;
      --font:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      --max:1180px;
      --contentMax: 720px;
    }

    *{box-sizing:border-box}
    html,body{height:100%;min-height:100dvh}
    body{
      margin:0;
      font-family:var(--font);
      color:var(--text);
      background:
        radial-gradient(1100px 800px at 62% 22%, rgba(56,189,248,.08), transparent 55%),
        radial-gradient(900px 700px at 40% 78%, rgba(99,102,241,.06), transparent 60%),
        radial-gradient(900px 700px at 18% 20%, rgba(253,224,71,.05), transparent 62%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      overflow:hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }

    button,input,textarea{font-family:inherit}
    input,textarea{font-size:16px}
    button{cursor:pointer}

    .app{
      height:100dvh;
      max-width:var(--max);
      margin:0 auto;
      padding:10px;
      padding-bottom:calc(10px + env(safe-area-inset-bottom));
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:10px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border:1px solid var(--border);
      border-radius:var(--r1);
      background:rgba(0,0,0,.22);
      box-shadow:var(--shadow);
      padding:12px;
      min-width:0;
    }
    .brand{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .brand .title{
      font-weight:650;
      letter-spacing:.02em;
      font-size:14px;
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background:rgba(255,255,255,.22);
      box-shadow:0 0 0 4px rgba(255,255,255,.06);
    }
    .brand .subtitle{
      font-size:12px;
      color:var(--dim);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:72ch;
    }
    .chiprow{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .chip{
      border:1px solid rgba(56,189,248,.35);
      background:rgba(56,189,248,.10);
      color:rgba(210,245,255,.95);
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:6px;
      line-height:1;
    }
    .chip.warn{border-color:rgba(253,224,71,.35);background:rgba(253,224,71,.08);color:rgba(255,246,184,.95)}
    .chip.ok{border-color:rgba(34,197,94,.35);background:rgba(34,197,94,.10);color:rgba(195,255,220,.95)}
    .chip.bad{border-color:rgba(248,113,113,.40);background:rgba(248,113,113,.10);color:rgba(255,210,210,.95)}
    .chip.btn{
      cursor:pointer;
      transition:transform .06s ease, background .18s ease;
      border:1px solid rgba(56,189,248,.35);
    }
    .chip.btn:hover{transform:translateY(-1px);background:rgba(56,189,248,.14)}
    .chip.btn:active{transform:translateY(0px)}
    .chip.btn[disabled]{opacity:.45;cursor:not-allowed}

    .kbd{
      font-family:var(--mono);
      font-size:10px;
      padding:2px 6px;
      border:1px solid rgba(255,255,255,.18);
      border-bottom-color:rgba(255,255,255,.10);
      border-radius:8px;
      background:rgba(0,0,0,.25);
      color:rgba(255,255,255,.75);
    }

    .main{
      border:1px solid var(--border);
      border-radius:var(--r1);
      background:rgba(0,0,0,.18);
      box-shadow:var(--shadow);
      overflow:hidden;
      display:flex;
      min-height:0;
      position:relative;
    }
    .conversation{
      flex:1;
      display:flex;
      flex-direction:column;
      min-width:0;
      min-height:0;
    }
    .scroll{
      flex:1;
      overflow:auto;
      padding:18px 16px;
      scroll-behavior:smooth;
    }
    .scroll::-webkit-scrollbar{width:10px}
    .scroll::-webkit-scrollbar-thumb{background:rgba(255,255,255,.10);border-radius:999px}
    .scroll::-webkit-scrollbar-thumb:hover{background:rgba(255,255,255,.14)}

    .msg{
      display:flex;
      gap:10px;
      margin:10px 0;
      align-items:flex-start;
    }
    /* Avatars removed (v3 refinement) */
    /* User bubbles remain. */
    .bubble{
      max-width:min(var(--contentMax), 100%);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:10px 12px;
      background:rgba(16,18,24,.62);
      backdrop-filter: blur(10px);
      box-shadow:0 8px 26px rgba(0,0,0,.25);
      line-height:1.35;
      overflow-wrap:anywhere;
      font-size:15px;
    }
    .msg.me{justify-content:flex-end}
    .msg.me .bubble{
      background:rgba(56,189,248,.10);
      border-color:rgba(56,189,248,.22);
    }
    .bubble pre{
      margin:10px 0 0;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.30);
      font-family:var(--mono);
      font-size:12px;
      overflow:auto;
      max-width:100%;
    }
    .bubble code{font-family:var(--mono);font-size:12px}

    /* Alice presence grammar: free-flow prose (no bubble). */
    .aliceProse{
      max-width:min(var(--contentMax), 100%);
      line-height:1.62;
      font-size:16px;
      color:rgba(255,255,255,.90);
      padding:2px 0;
      overflow-wrap:anywhere;
      letter-spacing: .005em;
    }
    .aliceProse p{margin:0 0 14px 0}
    .aliceProse p:last-child{margin-bottom:0}
    .aliceProse h3{
      margin:2px 0 10px 0;
      font-size:18px;
      letter-spacing:.01em;
      font-weight:700;
    }
    .aliceProse h4{
      margin:2px 0 10px 0;
      font-size:15px;
      letter-spacing:.01em;
      font-weight:700;
      color:rgba(255,255,255,.86);
      text-transform:none;
    }
    .aliceProse ul{
      margin:0 0 12px 18px;
      padding:0;
    }
    .aliceProse li{margin:6px 0}
    /* System messages (no avatars) */
    .msg.system{justify-content:flex-start}
    .msg.system .bubble{
      background:rgba(255,255,255,.04);
      border-color:rgba(255,255,255,.10);
      color:rgba(255,255,255,.80);
    }

    .card{
      margin-top:10px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:16px;
      background:rgba(0,0,0,.18);
      padding:10px 12px;
    }
    .card h4{
      font-size:12px;
      color:rgba(255,255,255,.80);
      font-weight:650;
      letter-spacing:.02em;
      margin:0 0 8px 0;
      text-transform:uppercase;
    }
    .card .hint{font-size:12px;color:var(--muted);line-height:1.35}
    .card .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-top:10px}

    .btn{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.88);
      padding:8px 10px;
      border-radius:12px;
      font-size:12px;
      line-height:1;
      transition:transform .06s ease, background .18s ease, border-color .18s ease;
      user-select:none;
    }
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.08)}
    .btn:active{transform:translateY(0)}
    .btn.primary{border-color:rgba(56,189,248,.30);background:rgba(56,189,248,.12)}
    .btn.danger{border-color:rgba(248,113,113,.38);background:rgba(248,113,113,.12)}
    .btn.ghost{background:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    .composer{
      border:1px solid var(--border);
      border-radius:var(--r1);
      background:rgba(0,0,0,.20);
      box-shadow:var(--shadow);
      padding:10px;
      padding-bottom:calc(10px + env(safe-area-inset-bottom));
      display:flex;
      gap:10px;
      align-items:flex-end;
      min-height:64px;
      position:relative;
    }
    .inputwrap{
      flex:1;
      display:flex;
      align-items:flex-end;
      gap:10px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.22);
      border-radius:18px;
      padding:10px 12px;
      min-height:56px;
    }
    textarea{
      width:100%;
      border:none;
      outline:none;
      resize:none;
      background:transparent;
      color:var(--text);
      font-size:16px;
      line-height:1.35;
      min-height:32px;
      max-height:220px;
      -webkit-text-size-adjust:100%;
    }
    textarea::placeholder{color:rgba(255,255,255,.40)}
    .send{
      flex:0 0 auto;
      height:44px;
      min-width:76px;
      padding:0 16px;
      border-radius:14px;
      border:1px solid rgba(56,189,248,.30);
      background:rgba(56,189,248,.14);
      color:rgba(230,250,255,.95);
      font-size:13px;
      line-height:1;
    }
    .send[disabled]{opacity:.45;cursor:not-allowed}

    /* Tasks overlay */
    .overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.45);
      display:none;
      align-items:stretch;
      justify-content:flex-end;
      z-index:50;
    }
    .overlay.open{display:flex}
    .sheet{
      width:min(520px, 100%);
      height:100%;
      background:var(--panel2);
      border-left:1px solid var(--border);
      box-shadow:var(--shadow);
      display:flex;
      flex-direction:column;
    }
    @media (max-width: 720px){
      .sheet{width:100%; border-left:none;}
    }
    .sheetheader{
      padding:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
    }
    .sheetheader .left{display:flex; flex-direction:column; gap:3px; min-width:0;}
    .sheetheader .left strong{font-size:13px; letter-spacing:.02em;}
    .sheetheader .left span{
      font-size:11px; color:var(--dim);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width:54ch;
    }
    .sheetbody{
      flex:1;
      overflow:auto;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .task{
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      background:rgba(0,0,0,.16);
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .task .top{display:flex; align-items:flex-start; justify-content:space-between; gap:10px;}
    .task .name{font-size:13px; font-weight:650; letter-spacing:.01em; line-height:1.25;}
    .task .small{font-size:11px;color:var(--dim); line-height:1.2;}
    .task .status{
      font-size:11px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.80);
      white-space:nowrap;
      user-select:none;
    }
    .status.pending{border-color:rgba(253,224,71,.26);background:rgba(253,224,71,.08);color:rgba(255,246,184,.95)}
    .status.running{border-color:rgba(56,189,248,.26);background:rgba(56,189,248,.10);color:rgba(210,245,255,.95)}
    .status.done{border-color:rgba(34,197,94,.28);background:rgba(34,197,94,.10);color:rgba(195,255,220,.95)}
    .status.failed{border-color:rgba(248,113,113,.30);background:rgba(248,113,113,.10);color:rgba(255,210,210,.95)}
    .task .actions{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;}
    .empty{
      border:1px dashed rgba(255,255,255,.18);
      border-radius:16px;
      padding:18px 16px;
      color:var(--muted);
      background:rgba(0,0,0,.12);
      font-size:12px;
      line-height:1.35;
    }

    /* Toast */
    .toast{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      z-index:70;
      max-width:min(740px, calc(100% - 20px));
      border:1px solid rgba(255,255,255,.14);
      background:rgba(12,14,18,.86);
      backdrop-filter: blur(10px);
      border-radius:16px;
      padding:10px 12px;
      box-shadow:var(--shadow);
      display:none;
      gap:10px;
      align-items:flex-start;
    }
    .toast.show{display:flex}
    .toast .t{flex:1; font-size:12px; color:rgba(255,255,255,.86); line-height:1.35;}
    .toast .x{
      border:none;
      background:transparent;
      color:rgba(255,255,255,.70);
      font-size:18px;
      line-height:1;
      padding:0 4px;
      cursor:pointer;
    }

    /* FAIL-CLOSED overlay (base key missing) */
    .fatal{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      background:rgba(0,0,0,.55);
      z-index:40;
    }
    .fatal.show{display:flex}
    .fatalbox{
      width:min(760px, 100%);
      border:1px solid rgba(255,255,255,.16);
      border-radius:18px;
      background:rgba(12,14,18,.90);
      box-shadow:var(--shadow);
      padding:14px 14px 12px;
    }
    .fatalbox h3{
      margin:0 0 8px 0;
      font-size:13px;
      letter-spacing:.02em;
      text-transform:uppercase;
      color:rgba(255,246,184,.95);
    }
    .fatalbox p{
      margin:0 0 10px 0;
      font-size:13px;
      line-height:1.35;
      color:rgba(255,255,255,.86);
    }
    .fatalbox .small{
      font-size:12px;
      color:rgba(255,255,255,.66);
      line-height:1.35;
      font-family:var(--mono);
      white-space:pre-wrap;
      user-select:text;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.25);
      border-radius:14px;
      padding:10px 12px;
    }

    /* Restraint body language: quiet the frame slightly when Alice chooses RESTRAIN */
    .restrained .topbar{opacity:.92}
    .restrained .composer{opacity:.92}
    .restrained .main{border-color:rgba(255,255,255,.10)}
    .presenceGlyph{opacity:.88}

    :focus-visible{
      outline:2px solid rgba(56,189,248,.55);
      outline-offset:2px;
      border-radius:12px;
    }

    /* v3 Presence Grammar indicator */
    .presenceRow{display:flex; margin:10px 0; align-items:flex-start;}
    .presenceGlyph{
      max-width:min(var(--contentMax), 100%);
      padding:2px 0;
      font-size:20px;
      line-height:1;
      color:rgba(255,255,255,.70);
      user-select:none;
    }
    .breatheDot{
      width:10px;height:10px;border-radius:999px;
      background:rgba(255,255,255,.70);
      display:inline-block;
      transform-origin:center;
      animation: breathe 1.15s ease-in-out infinite;
      box-shadow:0 0 0 6px rgba(255,255,255,.06);
    }
    @keyframes breathe{
      0%{ transform:scale(.92); opacity:.55; }
      50%{ transform:scale(1.08); opacity:.90; }
      100%{ transform:scale(.92); opacity:.55; }
    }
  
    /* Tool artifact styling (ChatGPT-like: subtle label + code block) */
    .toolLabel{
      font-family:var(--mono);
      font-size:12px;
      color:rgba(255,255,255,.62);
      margin:0 0 8px 0;
      letter-spacing:.01em;
      user-select:text;
    }
    .aliceProse pre{
      margin:0 0 12px 0;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.28);
      font-family:var(--mono);
      font-size:12px;
      overflow:auto;
      max-width:100%;
      line-height:1.45;
      color:rgba(255,255,255,.88);
      white-space:pre;
    }
    .aliceProse .sources{
      margin-top:12px;
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      background:rgba(0,0,0,.16);
      padding:8px 10px;
    }
    .aliceProse .sources > summary{
      cursor:pointer;
      font-size:12px;
      color:rgba(255,255,255,.75);
      list-style:none;
      user-select:none;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .aliceProse .sources > summary::-webkit-details-marker{display:none}
    .aliceProse .sourcesList{
      margin:10px 0 0 0;
      padding:0;
      list-style:none;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .aliceProse .src{
      font-size:12px;
      color:rgba(255,255,255,.70);
      overflow-wrap:anywhere;
    }
    .aliceProse .src a{
      color:rgba(210,245,255,.95);
      text-decoration:none;
      border-bottom:1px solid rgba(56,189,248,.25);
    }
    .aliceProse .src a:hover{border-bottom-color:rgba(56,189,248,.55)}

  </style>
</head>

<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="title"><span class="dot" id="healthDot"></span> Alice</div>
        <div class="subtitle" id="subtitle">Conversation-first. Tasks only appear when you ask.</div>
      </div>

      <div class="chiprow">
        <div class="chip" id="healthChip">Backend: unknown</div>

        <button class="chip btn" id="tasksChip" type="button" title="Show tasks (or type: show tasks)">
          Tasks <span id="tasksCount" class="kbd">0</span>
        </button>

        <button class="chip btn warn" id="adminChip" type="button" title="Unlock admin (or type: unlock admin)">
          Admin <span id="adminState" class="kbd">locked</span>
        </button>
      </div>
    </header>

    <main class="main">
      <section class="conversation" aria-label="Conversation">
        <div class="scroll" id="scroll">
          <div id="messages"></div>
        </div>
      </section>

      <!-- Fail-closed overlay when base API key is missing -->
      <div class="fatal" id="fatalOverlay" role="alert" aria-live="assertive">
        <div class="fatalbox">
          <h3>Base API key missing (fail-closed)</h3>
          <p>
            Alice cannot send any requests without the constant base API key.
            This key is never entered through chat. Provide it via deploy-time meta tag
            or legacy localStorage.
          </p>
          <div class="small" id="fatalDetails"></div>
        </div>
      </div>
    </main>

    <footer class="composer" aria-label="Message composer">
      <div class="inputwrap">
        <textarea id="input" rows="1" placeholder="Message Alice…"></textarea>
        <button class="send" id="sendBtn" type="button">Send</button>
      </div>
    </footer>
  </div>

  <div class="overlay" id="tasksOverlay" role="dialog" aria-modal="true" aria-label="Tasks">
    <div class="sheet" role="document">
      <div class="sheetheader">
        <div class="left">
          <strong>Tasks</strong>
          <span id="tasksSubtitle">Loaded on request. No background polling.</span>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button class="btn" id="refreshTasksBtn" type="button">Refresh</button>
          <button class="btn ghost" id="closeTasksBtn" type="button">Close</button>
        </div>
      </div>
      <div class="sheetbody" id="tasksBody">
        <div class="empty">Say “show tasks” to open this panel. Tasks do not compete with conversation for authority.</div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite">
    <div class="t" id="toastText"></div>
    <button class="x" id="toastClose" type="button" aria-label="Close">×</button>
  </div>

  <script>
(() => {
  'use strict';

  // ---------- DOM ----------
  const $ = (sel) => document.querySelector(sel);
  const els = {};

  function bindEls() {
    els.healthDot   = $('#healthDot');
    els.healthChip  = $('#healthChip');
    els.tasksChip   = $('#tasksChip');
    els.tasksCount  = $('#tasksCount');
    els.adminChip   = $('#adminChip');
    els.adminState  = $('#adminState');

    els.scroll      = $('#scroll');
    els.messages    = $('#messages');

    els.input       = $('#input');
    els.sendBtn     = $('#sendBtn');

    els.tasksOverlay     = $('#tasksOverlay');
    els.tasksBody        = $('#tasksBody');
    els.refreshTasksBtn  = $('#refreshTasksBtn');
    els.closeTasksBtn    = $('#closeTasksBtn');

    els.toast       = $('#toast');
    els.toastText   = $('#toastText');
    els.toastClose  = $('#toastClose');

    els.fatalOverlay = $('#fatalOverlay');
    els.fatalDetails = $('#fatalDetails');

    els.subtitle = $('#subtitle');
  }

  // ---------- API ----------
  const API = {
    health: '/health',
    ask: '/ask',
    gateAdvance: '/alice/gate/advance',
    adminUnlock: '/auth/admin/unlock',
    tasksList: '/tasks',
    taskGet: (id) => `/tasks/${id}`,
    taskResume: (id) => `/tasks/${id}/resume`,
    taskAbort: (id) => `/tasks/${id}/abort`,

    toolsCall: '/tools/call',

    // Identity & Memory v1
    idMe: '/alice/identity/users/me',
    idResolve: '/alice/identity/users/resolve',
    memShow: '/alice/memory/show',
    memWrite: '/alice/memory/write',
    memForget: '/alice/memory/forget',
    adminInbox: '/alice/admin/inbox',

    memoryCandidates: {
      concepts: [
        '/alice/memory/concepts',
        '/memory/concepts',
        '/alice/memory/concept',
        '/memory/concept',
      ],
    },
  };

  // ---------- State ----------
  const state = {
    apiKey: null,            // REQUIRED for every request (constant; never entered via UI)
    adminToken: null,        // session-only
    adminUnlocked: false,
    backendOk: null,

    tasksOpen: false,
    tasks: [],

    pendingMemory: null,     // { kind:'write'|'delete'|'memv1_write'|'memv1_forget', key:'...', value?:'...' }

    memoryEndpoints: { conceptsBase: null },

    lastDecision: null,      // 'RESTRAIN'|'CLARIFY'|'ADVANCE_OK'|null

    presence: { mode: 'off' }, // 'off'|'breathing'|'ellipsis'


    // ---------- Local read cursor (v4-B) ----------
    // Conversation-local cursor to support chunked reads without raising caps.
    localRead: {
      lastPath: null,
      lastChunk: 200,
      cursorByPath: {}, // path -> next_start_line (1-based)
    },
  };
  // ---------- Identity (v4-A minimal) ----------
  // For now, user_id is a simple stable identifier provided by the client.
  // No UI for this yet; default to "tim". (Can be overridden manually via localStorage.)
  function getUserId() {
    try {
      const v = (localStorage.getItem('isac_user_id') || '').trim();
      if (v) return v;
    } catch {}
    return 'tim';
  }

  // ---------- Tools (retrieval-only unified flow) ----------
  function isShowSourcesRequest(text) {
    const t = String(text || '').toLowerCase();
    return t.includes('show sources') || t.includes('sources') || t.includes('where did') || t.includes('citation');
  }
  function isShowToolOutputRequest(text) {
    const t = String(text || '').toLowerCase();
    return t.includes('show tool') || t.includes('show output') || t.includes('raw') || t.includes('details');
  }

  async function toolsCall(tool_name, purpose, args) {
    const chatId = state.chat?.id || 'unknown';
    const userId = getUserId();
    const headers = {
      'X-ISAC-USER-ID': userId,
      'X-ISAC-CHAT-ID': chatId,
    };
    const body = { tool_name, purpose, args: args || {} };
    return await fetchJson(API.toolsCall, { method: 'POST', headers, body: JSON.stringify(body) });
  }

  function basename(p) {
    const s = String(p || '').trim();
    if (!s) return '';
    const parts = s.split('/');
    return parts[parts.length - 1] || s;
  }

  // ----- Local read cursor helpers (v4-B) -----
  function _lrNormalizePath(p) {
    return String(p || '').trim();
  }

  function _lrGetChunkDefault() {
    const n = parseInt(state.localRead?.lastChunk || 200, 10);
    return (Number.isFinite(n) && n > 0) ? Math.min(400, n) : 200; // conservative cap
  }

  function _lrGetNextStart(path) {
    const p = _lrNormalizePath(path);
    if (!p) return 1;
    const cur = state.localRead?.cursorByPath?.[p];
    const n = parseInt(cur || 1, 10);
    return (Number.isFinite(n) && n >= 1) ? n : 1;
  }

  function _lrSetCursor(path, nextStart) {
    const p = _lrNormalizePath(path);
    if (!p) return;
    const ns = parseInt(nextStart || 1, 10);
    if (!Number.isFinite(ns) || ns < 1) return;
    if (!state.localRead) state.localRead = { lastPath: null, lastChunk: 200, cursorByPath: {} };
    if (!state.localRead.cursorByPath) state.localRead.cursorByPath = {};
    state.localRead.cursorByPath[p] = ns;
    state.localRead.lastPath = p;
  }

  function _lrSetLast(path, chunkSize) {
    const p = _lrNormalizePath(path);
    if (!p) return;
    if (!state.localRead) state.localRead = { lastPath: null, lastChunk: 200, cursorByPath: {} };
    state.localRead.lastPath = p;
    const cs = parseInt(chunkSize || state.localRead.lastChunk || 200, 10);
    if (Number.isFinite(cs) && cs > 0) state.localRead.lastChunk = Math.min(400, cs);
  }

  function _lrResolveContinuePath() {
    return _lrNormalizePath(state.localRead?.lastPath || '');
  }

  function renderSourcesDetails(prov) {
    const sources = Array.isArray(prov?.sources) ? prov.sources : [];
    if (!sources.length) return '';
    const items = sources.slice(0, 12).map(src => {
      const u = String(src || '');
      const safe = esc(u);
      const isUrl = /^https?:\/\//i.test(u);
      return `<li class="src">${isUrl ? `<a href="${safe}" target="_blank" rel="noopener noreferrer">${safe}</a>` : safe}</li>`;
    }).join('');
    return `
      <details class="sources">
        <summary>Sources</summary>
        <ul class="sourcesList">${items}</ul>
      </details>
    `;
  }

  function sayAliceArtifact(label, preText, proseText, prov, showSources = true) {
    // Presence must disappear the instant Alice begins speaking.
    removePresence();

    const prose = document.createElement('div');
    prose.className = 'aliceProse';

    const labelHtml = label ? `<div class="toolLabel">${esc(label)}</div>` : '';
    const preHtml = `<pre>${esc(String(preText || ''))}</pre>`;
    const bodyHtml = (proseText ? aliceHtmlFromText(String(proseText)) : '');
    const sourcesHtml = showSources ? renderSourcesDetails(prov) : '';

    prose.innerHTML = `${labelHtml}${preHtml}${bodyHtml}${sourcesHtml}`;

    addRow('alice', prose);

    // Store in session transcript as a plain-text approximation (prose only, keep it simple).
    const t = (proseText || '').toString().trim() || label || '';
    appendMessage('alice', t);
  }

  function formatWebSummary(results) {
    const arr = Array.isArray(results) ? results : [];
    if (!arr.length) return 'I didn’t find any usable results.';
    const top = arr.slice(0, 6).map(r => {
      const title = String(r?.title || r?.url || '').trim();
      const dom = String(r?.domain || '').trim();
      return `- ${title}${dom ? ` (${dom})` : ''}`;
    }).join('\n');
    return `# Results\n${top}`;
  }

  function formatWeatherSummary(primary) {
    try {
      const loc = primary?.location?.name || primary?.location?.query || 'that location';
      const daily = primary?.daily || {};
      const dates = daily?.time || [];
      const tmax = daily?.temperature_2m_max || [];
      const tmin = daily?.temperature_2m_min || [];
      const n = Math.min(3, dates.length, tmax.length, tmin.length);
      if (!n) return `I couldn’t extract a forecast for ${loc}.`;
      let out = `# Weather — ${loc}\n`;
      for (let i=0;i<n;i++){
        out += `- ${dates[i]}: ${tmin[i]}–${tmax[i]}\n`;
      }
      return out.trim();
    } catch {
      return 'I couldn’t extract a forecast.';
    }
  }

  function parseToolCommand(userText) {
    const raw = String(userText || '').trim();
    const low = raw.toLowerCase();

    // WEB: "search the web for X"
    let m = raw.match(/^search\s+the\s+web\s+for\s+(.+)$/i);
    if (m && m[1]) {
      const q = m[1].trim();
      return {
        tool_name: 'web.search',
        purpose: `Find sources about: ${q}`,
        args: {
          intent: 'lookup',
          user_prompt_excerpt: raw.slice(0, 180),
          risk_tier: 2,
          queries: [q],
          max_results: 8,
        },
        render_mode: 'silent',
      };
    }

    // LOCAL: "read file PATH"
    m = raw.match(/^read\s+file\s+(.+)$/i);
    if (m && m[1]) {
      const p = m[1].trim();
      // v4-B: remember this file for subsequent 'continue' chunk reads
      _lrSetLast(p, _lrGetChunkDefault());
      return {
        tool_name: 'local.read_file',
        purpose: `Read file for context: ${p}`,
        args: { path: p },
        render_mode: 'card',
      };
    }

    // LOCAL: "read lines A-B of PATH"
    m = raw.match(/^read\s+lines?\s+(\d+)\s*-\s*(\d+)\s+of\s+(.+)$/i);
    if (m && m[1] && m[2] && m[3]) {
      const a = parseInt(m[1], 10);
      const b = parseInt(m[2], 10);
      const p = m[3].trim();
      // v4-B: remember this file for subsequent 'continue' chunk reads
      _lrSetLast(p, Math.min(400, Math.max(1, (b - a + 1))));
      return {
        tool_name: 'local.read_snippet',
        purpose: `Read lines ${a}-${b} for context: ${p}`,
        args: { path: p, start_line: a, end_line: b },
        render_mode: 'card',
      };
    }

    // LOCAL (v4-B): "read next N lines of PATH" (chunked, cursor-based)
    // Examples:
    //   read next 200 lines of /opt/jarvis/brain/main.py
    //   read next lines of /opt/jarvis/brain/main.py   (uses lastChunk)
    m = raw.match(/^read\s+next(?:\s+(\d+))?\s+lines?\s+of\s+(.+)$/i);
    if (m && m[2]) {
      const n = m[1] ? parseInt(m[1], 10) : _lrGetChunkDefault();
      const p = m[2].trim();
      const size = (Number.isFinite(n) && n > 0) ? Math.min(400, n) : _lrGetChunkDefault();
      const start = _lrGetNextStart(p);
      const end = start + size - 1;
      _lrSetLast(p, size);
      return {
        tool_name: 'local.read_snippet',
        purpose: `Read next ${size} lines for context: ${p}`,
        args: { path: p, start_line: start, end_line: end },
        render_mode: 'card',
      };
    }

    // LOCAL (v4-B): "continue" / "next" to read the next chunk of the last file
    if (/^(continue|next|more|read\s+next)$/i.test(raw)) {
      const p = _lrResolveContinuePath();
      if (p) {
        const size = _lrGetChunkDefault();
        const start = _lrGetNextStart(p);
        const end = start + size - 1;
        _lrSetLast(p, size);
        return {
          tool_name: 'local.read_snippet',
          purpose: `Read next ${size} lines for context: ${p}`,
          args: { path: p, start_line: start, end_line: end },
          render_mode: 'card',
        };
      }
      // If no lastPath, fall through to normal handling.
    }


    // UTILITY: "weather LOCATION"
    m = raw.match(/^weather\s+(.+)$/i);
    if (m && m[1]) {
      const loc = m[1].trim();
      return {
        tool_name: 'util.weather',
        purpose: `Get weather for: ${loc}`,
        args: { location: loc, days: 3 },
        render_mode: 'silent',
      };
    }

    // UTILITY: "calc EXPR"
    m = raw.match(/^calc\s+(.+)$/i);
    if (m && m[1]) {
      const expr = m[1].trim();
      return {
        tool_name: 'util.calc',
        purpose: 'Evaluate a basic expression',
        args: { expression: expr },
        render_mode: 'silent',
      };
    }

    // UTILITY: "time OFFSET"
    m = raw.match(/^time\s+([+-]\d{2}:\d{2}|utc|z)$/i);
    if (m && m[1]) {
      const off = m[1].toUpperCase() === 'UTC' ? '+00:00' : (m[1].toUpperCase() === 'Z' ? '+00:00' : m[1]);
      return {
        tool_name: 'util.time',
        purpose: `Get current time for offset ${off}`,
        args: { offset: off },
        render_mode: 'silent',
      };
    }

    return null;
  }

  async function handleToolCommand(cmd, userText) {
    // Run tool via backend
    const data = await toolsCall(cmd.tool_name, cmd.purpose, cmd.args);
    const r = data?.result || {};
    const ok = !!r.ok;

    // Policy: failures always surface as artifact
    const forceCard = !ok || cmd.render_mode === 'card' || isShowToolOutputRequest(userText);

    if (cmd.tool_name.startsWith('local.')) {
      // LOCAL_READ: tool output *is* deliverable
      const p = cmd.args?.path || '';
      const label = `${cmd.tool_name} on ${basename(p) || 'file'}`;
      if (!ok) {
        sayAliceArtifact(label, String(r.failure_message || 'Tool failed'), '', r.provenance, false);
        return;
      }
      if (cmd.tool_name === 'local.read_snippet') {
        const lines = Array.isArray(r.primary?.lines) ? r.primary.lines : [];
        const pre = lines.join('\n');


        // v4-B: advance cursor for this path (best-effort)
        try {
          const p2 = String(cmd.args?.path || '').trim();
          const endLine = parseInt(cmd.args?.end_line || 0, 10);
          if (p2 && Number.isFinite(endLine) && endLine >= 1) _lrSetCursor(p2, endLine + 1);
        } catch {}
        sayAliceArtifact(label, pre, '', r.provenance, false);
        return;
      } else {
        const content = String(r.primary?.content || '');
        sayAliceArtifact(label, content, '', r.provenance, false);
        return;
      }
    }

    // WEB / UTILITY
    if (forceCard) {
      const label = `${cmd.tool_name}`;
      const pre = ok ? JSON.stringify(r.primary || {}, null, 2) : String(r.failure_message || 'Tool failed');
      const prose = ok ? '' : '';
      sayAliceArtifact(label, pre, prose, r.provenance);
      return;
    }

    // Silent default: synthesize in prose
    if (!ok) {
      // Even in silent mode, a failure should surface
      const label = `${cmd.tool_name}`;
      sayAliceArtifact(label, String(r.failure_message || 'Tool failed'), '', r.provenance, false);
      return;
    }

    let prose = '';
    if (cmd.tool_name === 'web.search') {
      prose = formatWebSummary(r.primary?.results || []);
    } else if (cmd.tool_name === 'util.weather') {
      prose = formatWeatherSummary(r.primary || {});
    } else if (cmd.tool_name === 'util.calc') {
      prose = `# Result\n- ${String(r.primary?.expression || '')} = ${String(r.primary?.result ?? '')}`;
    } else if (cmd.tool_name === 'util.time') {
      prose = `# Time\n- UTC: ${String(r.primary?.utc_now || '')}\n- Local (${String(r.primary?.offset || '')}): ${String(r.primary?.local_now || '')}`;
    } else {
      prose = '# Result\n' + JSON.stringify(r.primary || {}, null, 2);
    }

    // Add sources panel only when user asked for sources (ChatGPT-like)
    if (isShowSourcesRequest(userText)) {
      sayAliceArtifact('', '', prose, r.provenance);
    } else {
      sayAlice(stripSpeakerPrefix(prose));
    }
  }



  // ---------- Utilities ----------
  const esc = (s) => String(s ?? '')
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#39;');

  function stripSpeakerPrefix(text) {
    const t = String(text || '').trim();
    // Guardrail: backend should never emit this, but we fail-safe in the renderer.
    return t.replace(/^(alice|assistant|jarvis)\s*:\s*/i, '').trim();
  }

  function toast(msg) {
    if (!els.toast || !els.toastText) return;
    els.toastText.textContent = msg;
    els.toast.classList.add('show');
    setTimeout(() => els.toast?.classList.remove('show'), 3500);
  }

  function setSubtitle(text) {
    if (!els.subtitle) return;
    els.subtitle.textContent = text;
  }

  function setHealth(ok) {
    state.backendOk = ok;
    if (!els.healthChip || !els.healthDot) return;

    els.healthChip.classList.remove('ok','bad');
    els.healthDot.style.background = 'rgba(255,255,255,.22)';

    if (ok === true) {
      els.healthChip.textContent = 'Backend: ok';
      els.healthChip.classList.add('ok');
      els.healthDot.style.background = 'rgba(34,197,94,.90)';
    } else if (ok === false) {
      els.healthChip.textContent = 'Backend: down';
      els.healthChip.classList.add('bad');
      els.healthDot.style.background = 'rgba(248,113,113,.92)';
    } else {
      els.healthChip.textContent = 'Backend: unknown';
    }
  }

  function setAdminUI() {
    if (!els.adminState || !els.adminChip) return;
    els.adminState.textContent = state.adminUnlocked ? 'unlocked' : 'locked';
    els.adminChip.classList.toggle('ok', !!state.adminUnlocked);
    els.adminChip.classList.toggle('warn', !state.adminUnlocked);
  }

  function setTasksCount(n) {
    if (els.tasksCount) els.tasksCount.textContent = String(n ?? 0);
  }

  function scrollToBottom() {
    if (!els.scroll) return;
    els.scroll.scrollTop = els.scroll.scrollHeight;
  }

  // ---------- Micro-timing (v3 polish) ----------
  // ChatGPT-like cadence: ACK dot appears immediately, then a short, human pause before any visible response.
  const TIMING = {
    minAckMs: 140,        // minimum time the breathing dot should be visible
    restraintResolveMs: 180, // breathing dot → ellipsis
  };
  let _ackStartedAt = 0;

  function markAckStart() { _ackStartedAt = performance.now(); }
  async function ensureMinAck(ms) {
    const want = (typeof ms === 'number') ? ms : TIMING.minAckMs;
    const elapsed = performance.now() - (_ackStartedAt || 0);
    const remain = want - elapsed;
    if (remain > 0) await new Promise(r => setTimeout(r, Math.min(600, remain)));
  }

  // ---------- Transcript (session-only) ----------
  const CHAT_STORAGE = {
    id: 'alice_chat_id_v1',
    messages: 'alice_chat_messages_v1'
  };

  function uuidv4() {
    try { return crypto.randomUUID(); }
    catch { return 'chat_' + Math.random().toString(16).slice(2) + Date.now().toString(16); }
  }

  function loadChatFromSession() {
    let chatId = null;
    let msgs = [];
    try { chatId = sessionStorage.getItem(CHAT_STORAGE.id); } catch {}
    try {
      const raw = sessionStorage.getItem(CHAT_STORAGE.messages);
      if (raw) msgs = JSON.parse(raw) || [];
    } catch {}

    if (!chatId) {
      chatId = uuidv4();
      msgs = [];
      try { sessionStorage.setItem(CHAT_STORAGE.id, chatId); } catch {}
      try { sessionStorage.setItem(CHAT_STORAGE.messages, JSON.stringify(msgs)); } catch {}
    }

    state.chat = { id: chatId, messages: Array.isArray(msgs) ? msgs : [] };
  }

  function persistChatToSession() {
    if (!state.chat) return;
    try { sessionStorage.setItem(CHAT_STORAGE.id, state.chat.id); } catch {}
    try { sessionStorage.setItem(CHAT_STORAGE.messages, JSON.stringify(state.chat.messages || [])); } catch {}
  }

  function clearChatSession() {
    try { sessionStorage.removeItem(CHAT_STORAGE.id); } catch {}
    try { sessionStorage.removeItem(CHAT_STORAGE.messages); } catch {}
    state.chat = { id: uuidv4(), messages: [] };
    persistChatToSession();
  }

  function appendMessage(role, text) {
    if (!state.chat) loadChatFromSession();
    const msg = {
      id: uuidv4(),
      role,                // 'me' | 'alice' | 'system'
      text: String(text ?? ''),
      ts: Date.now(),
    };
    state.chat.messages.push(msg);
    const MAX = 220;
    if (state.chat.messages.length > MAX) state.chat.messages = state.chat.messages.slice(-MAX);
    persistChatToSession();
  }

  // ---------- v3 Presence Grammar ----------
  // Immediate acknowledgment = breathing dot.
  // Dot disappears at the instant Alice begins speaking.
  // If RESTRAIN: breathing dot resolves to static “…” (no animation, no escalation).
  const PRESENCE_ID = 'presenceRow';

  function removePresence() {
    const el = document.getElementById(PRESENCE_ID);
    if (el) el.remove();
    state.presence.mode = 'off';
    document.body.classList.remove('restrained');
  }

  function showPresence(mode) {
    removePresence();
    if (!els.messages) return;

    if (mode !== 'breathing' && mode !== 'ellipsis') return;

    const row = document.createElement('div');
    row.className = 'presenceRow';
    row.id = PRESENCE_ID;
    const glyph = document.createElement('div');
    glyph.className = 'presenceGlyph';

    if (mode === 'breathing') {
      glyph.innerHTML = `<span class="breatheDot" aria-label="Alice is engaged"></span>`;
    } else {
      glyph.textContent = '…';
      glyph.setAttribute('aria-label', 'Alice is listening');
    }

    row.appendChild(glyph);
    els.messages.appendChild(row);
    state.presence.mode = mode;
    document.body.classList.toggle('restrained', mode === 'ellipsis');
    scrollToBottom();
  }

  // ---------- Renderers ----------
  function addRow(role, node) {
    if (!els.messages) return;

    const row = document.createElement('div');
    row.className = `msg ${role === 'me' ? 'me' : role === 'system' ? 'system' : ''}`;
    row.appendChild(node);
    els.messages.appendChild(row);
    scrollToBottom();
  }

  function sayMe(text) {
    const t = String(text ?? '');
    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    bubble.innerHTML = `<div>${esc(t)}</div>`;
    addRow('me', bubble);
    appendMessage('me', t);
  }

  // Alice: free-flow prose, no bubble.
  function aliceHtmlFromText(text) {
    const raw = String(text ?? '').replace(/\r\n/g, '\n').trim();
    if (!raw) return '<p>(no reply)</p>';

    const lines = raw.split('\n');
    const blocks = [];
    let para = [];
    let list = [];

    const flushPara = () => {
      if (!para.length) return;
      blocks.push({ type:'p', text: para.join(' ').trim() });
      para = [];
    };
    const flushList = () => {
      if (!list.length) return;
      blocks.push({ type:'ul', items: list.slice() });
      list = [];
    };

    for (let i=0; i<lines.length; i++) {
      const line = lines[i].trim();
      if (!line) { flushList(); flushPara(); continue; }

      // Headings (# / ##). Keep minimal and predictable.
      if (line.startsWith('## ')) { flushList(); flushPara(); blocks.push({ type:'h4', text: line.slice(3).trim() }); continue; }
      if (line.startsWith('# '))  { flushList(); flushPara(); blocks.push({ type:'h3', text: line.slice(2).trim() }); continue; }

      // Bullets (minimal)
      if (line.startsWith('- ') || line.startsWith('• ')) {
        flushPara();
        list.push(line.slice(2).trim());
        continue;
      }

      flushList();
      para.push(line);
    }
    flushList();
    flushPara();

    const out = [];
    for (const b of blocks) {
      if (b.type === 'h3') out.push(`<h3>${esc(b.text)}</h3>`);
      else if (b.type === 'h4') out.push(`<h4>${esc(b.text)}</h4>`);
      else if (b.type === 'ul') out.push(`<ul>${b.items.map(it => `<li>${esc(it)}</li>`).join('')}</ul>`);
      else out.push(`<p>${esc(b.text)}</p>`);
    }
    return out.join('');
  }

  function sayAlice(text) {
    // Presence dot must disappear the instant Alice begins speaking.
    removePresence();

    const t = String(text ?? '');
    const prose = document.createElement('div');
    prose.className = 'aliceProse';
    prose.innerHTML = aliceHtmlFromText(t);

    addRow('alice', prose);
    appendMessage('alice', t);
  }

  // System note: factual, brief, never Alice voice.
  function systemNote(text) {
    removePresence();
    const t = String(text ?? '');
    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    bubble.innerHTML = `<div>${esc(t)}</div>`;
    addRow('system', bubble);
    appendMessage('system', t);
  }

  function systemCard(title, bodyHtml) {
    removePresence();
    const ttl = String(title ?? '').trim();
    const bubble = document.createElement('div');
    bubble.className = 'bubble';
    bubble.innerHTML = `<div class="card"><h4>${esc(ttl)}</h4>${bodyHtml || ''}</div>`;
    addRow('system', bubble);
    appendMessage('system', `${ttl}`);
  }

  function renderTranscriptFromState() {
    if (!els.messages) return;
    els.messages.innerHTML = '';
    const msgs = state.chat?.messages || [];
    for (const m of msgs) {
      if (m.role === 'me') {
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.innerHTML = `<div>${esc(m.text)}</div>`;
        addRow('me', bubble);
      } else if (m.role === 'system') {
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.innerHTML = `<div>${esc(m.text)}</div>`;
        addRow('system', bubble);
      } else {
        const prose = document.createElement('div');
        prose.className = 'aliceProse';
        prose.innerHTML = aliceHtmlFromText(m.text);
        addRow('alice', prose);
      }
    }
    scrollToBottom();
  }

  function buildContextBlockForModel(opts) {
    const excludeLast = opts?.excludeLast ?? false;
    let msgs = (state.chat?.messages || []).filter(m => m.role !== 'system');
    if (excludeLast && msgs.length) msgs = msgs.slice(0, -1);
    if (!msgs.length) return '';
    const slice = msgs.slice(-24);
    let out = 'Conversation so far (most recent last):\n';
    for (const m of slice) {
      const who = (m.role === 'me') ? 'User' : 'Alice';
      const line = String(m.text || '').trim();
      if (!line) continue;
      out += `${who}: ${line}\n`;
      if (out.length > 3500) break;
    }
    return out.trim();
  }

  function buildCtxArrayForGate(opts) {
    const excludeLast = opts?.excludeLast ?? false;
    let msgs = (state.chat?.messages || []).filter(m => m.role !== 'system');
    if (excludeLast && msgs.length) msgs = msgs.slice(0, -1);
    if (!msgs.length) return [];
    const slice = msgs.slice(-24);
    return slice
      .map(m => {
        const role = (m.role === 'me') ? 'user' : 'assistant';
        const content = String(m.text || '').trim();
        return { role, content };
      })
      .filter(m => m.content);
  }

  // ---------- Fail-closed behavior ----------
  function setFailClosed(on, details) {
    const disabled = !!on;

    if (els.fatalOverlay) els.fatalOverlay.classList.toggle('show', disabled);
    if (els.fatalDetails) els.fatalDetails.textContent = details || '';

    if (els.sendBtn) els.sendBtn.disabled = disabled;
    if (els.input) els.input.disabled = disabled;
    if (els.tasksChip) els.tasksChip.disabled = disabled;
    if (els.adminChip) els.adminChip.disabled = disabled;

    if (disabled) {
      setHealth(null);
      setTasksCount(0);
      setAdminUI();
    }
  }

  function readMetaBaseKey() {
    const el = document.querySelector('meta[name="jarvis-api-key"]');
    const v = (el?.getAttribute('content') || '').trim();
    if (!v) return null;
    if (v === '__SET_BASE_API_KEY_HERE__') return null;
    return v;
  }

  function loadAuth() {
    state.apiKey = readMetaBaseKey();
    if (!state.apiKey) {
      try {
        const k = localStorage.getItem('jarvis_api_key');
        if (k && String(k).trim()) state.apiKey = String(k).trim();
      } catch {}
    }

    state.adminToken = null;
    state.adminUnlocked = false;
    try { sessionStorage.removeItem('isac_admin_token'); } catch {}
    setAdminUI();

    if (!state.apiKey) {
      const help =
        "To set legacy localStorage (manual, outside UI):\n" +
        "  localStorage.setItem('jarvis_api_key', 'YOUR_BASE_KEY');\n" +
        "  location.reload();\n\n" +
        "Preferred: inject base key via <meta name=\"jarvis-api-key\"> at deploy time.";
      setFailClosed(true, help);
      return false;
    }

    setFailClosed(false, '');
    return true;
  }

  // ---------- Request wrapper ----------
  function buildHeaders(extra) {
    if (!state.apiKey) throw new Error('Base API key missing');

    const h = {
      'Content-Type': 'application/json',
      'X-API-Key': state.apiKey,
      'X-ISAC-USER-ID': getUserId(), // REQUIRED for Identity & Memory
    };

    if (state.adminUnlocked) {
      h['X-ISAC-ADMIN-KEY'] = state.apiKey;
      if (state.adminToken) h['X-ISAC-ADMIN-TOKEN'] = state.adminToken;
    }

    return { ...h, ...(extra || {}) };
  }

  function stringifyDetail(x) {
    if (x == null) return '';
    if (typeof x === 'string') return x;
    try { return JSON.stringify(x); } catch { return String(x); }
  }

  function firstQuestionOnly(q) {
    const s = String(q || '').trim();
    if (!s) return '';
    const qm = s.indexOf('?');
    if (qm !== -1) return (s.slice(0, qm + 1)).trim();
    return s.split('\n').map(x => x.trim()).filter(Boolean)[0] || s;
  }

  async function fetchJson(url, opts = {}) {
    const res = await fetch(url, {
      method: opts.method || 'GET',
      headers: buildHeaders(opts.headers),
      body: opts.body,
    });

    const ct = (res.headers.get('content-type') || '').toLowerCase();
    let data;
    if (ct.includes('application/json')) data = await res.json().catch(() => ({}));
    else data = { detail: (await res.text().catch(() => '')).slice(0, 1200) };

    if (!res.ok) {
      const msg = stringifyDetail(data?.detail) || stringifyDetail(data?.message) || `HTTP ${res.status}`;
      const err = new Error(msg);
      err.status = res.status;
      err.data = data;
      throw err;
    }
    return data;
  }

  // ---------- Health ----------
  async function checkHealth() {
    try {
      await fetchJson(API.health, { method: 'GET' });
      setHealth(true);
    } catch {
      setHealth(false);
    }
  }

  // ---------- Admin unlock (system UI only) ----------
  function showUnlockCard() {
    if (!state.apiKey) return;

    systemCard('PLAN · Conversational admin unlock', `
      <div class="hint">
        Enter your admin PIN to unlock this session. PIN is never stored. Token is session-only.
      </div>
      <div class="row">
        <input id="pinInput" type="password" placeholder="PIN"
          style="flex:1; padding:10px; border-radius:12px; border:1px solid rgba(255,255,255,.18); background:rgba(0,0,0,.25); color:rgba(255,255,255,.9);" />
        <button id="pinUnlock" class="btn primary" type="button">Unlock</button>
        <button id="pinCancel" class="btn" type="button">Cancel</button>
      </div>
    `);

    setTimeout(() => {
      const inp = $('#pinInput');
      const ok = $('#pinUnlock');
      const cancel = $('#pinCancel');
      if (!inp || !ok || !cancel) return;

      const doUnlock = async () => {
        const pin = String(inp.value || '').trim();
        if (!pin) { toast('PIN required.'); return; }
        try {
          const data = await fetchJson(API.adminUnlock, { method:'POST', body: JSON.stringify({ pin }) });
          const tok = String(data?.admin_token || data?.token || '').trim();
          if (!tok) throw new Error('Unlock returned no token');

          state.adminToken = tok;
          state.adminUnlocked = true;
          try { sessionStorage.setItem('isac_admin_token', tok); } catch {}
          setAdminUI();
          toast('Admin unlocked.');
        } catch (e) {
          state.adminToken = null;
          state.adminUnlocked = false;
          try { sessionStorage.removeItem('isac_admin_token'); } catch {}
          setAdminUI();
          toast(`Admin unlock failed (${e.status || 'ERR'}).`);
        }
      };

      ok.addEventListener('click', () => void doUnlock());
      inp.addEventListener('keydown', (e) => { if (e.key === 'Enter') void doUnlock(); });
      cancel.addEventListener('click', () => toast('Cancelled.'));
      inp.focus();
    }, 0);
  }

  function lockAdmin() {
    state.adminToken = null;
    state.adminUnlocked = false;
    state.pendingMemory = null;
    try { sessionStorage.removeItem('isac_admin_token'); } catch {}
    setAdminUI();
    toast('Admin locked.');
  }

  // ---------- Tasks overlay ----------
  function openTasks() {
    state.tasksOpen = true;
    if (els.tasksOverlay) els.tasksOverlay.classList.add('open');
    void loadTasks();
  }
  function closeTasks() {
    state.tasksOpen = false;
    if (els.tasksOverlay) els.tasksOverlay.classList.remove('open');
  }

  function renderTasks() {
    if (!els.tasksBody) return;

    const tasks = state.tasks || [];
    setTasksCount(tasks.length);

    if (!tasks.length) {
      els.tasksBody.innerHTML = `<div class="empty">No tasks found.</div>`;
      return;
    }

    els.tasksBody.innerHTML = '';
    for (const t of tasks) {
      const div = document.createElement('div');
      div.className = 'task';

      const status = String(t.status || 'unknown').toLowerCase();
      const statusClass = status.includes('complete') ? 'done'
        : status.includes('fail') ? 'failed'
        : status.includes('run') ? 'running'
        : 'pending';

      div.innerHTML = `
        <div class="top">
          <div>
            <div class="name">${esc(t.title || '(untitled)')}</div>
            <div class="small">ID: ${esc(t.id)}${t.resume_hint ? ' · ' + esc(t.resume_hint) : ''}</div>
          </div>
          <div class="status ${statusClass}">${esc(status)}</div>
        </div>
        <div class="actions">
          <button class="btn" data-act="details" data-id="${esc(t.id)}">Details</button>
          <button class="btn primary" data-act="resume" data-id="${esc(t.id)}">Resume</button>
          <button class="btn danger" data-act="abort" data-id="${esc(t.id)}">Abort</button>
        </div>
      `;
      els.tasksBody.appendChild(div);
    }

    els.tasksBody.querySelectorAll('button[data-act]').forEach(btn => {
      btn.addEventListener('click', () => {
        const act = btn.getAttribute('data-act');
        const id = btn.getAttribute('data-id');
        if (!id) return;
        if (act === 'details') void taskDetails(id);
        if (act === 'resume') void taskResume(id);
        if (act === 'abort') void taskAbort(id);
      });
    });
  }

  async function loadTasks() {
    try {
      const data = await fetchJson(API.tasksList, { method:'GET' });
      state.tasks = Array.isArray(data?.tasks) ? data.tasks : (Array.isArray(data) ? data : []);
      renderTasks();
    } catch (e) {
      toast(`Tasks load failed (${e.status || 'ERR'}).`);
    }
  }

  async function taskDetails(id) {
    try {
      const data = await fetchJson(API.taskGet(id), { method:'GET' });
      systemCard('RESULT · Task details', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
    } catch (e) {
      toast(`Details failed (${e.status || 'ERR'}).`);
    }
  }

  async function taskResume(id) {
    if (!state.adminUnlocked) { toast('Admin locked. Type: unlock admin'); return; }
    try {
      const data = await fetchJson(API.taskResume(id), { method:'POST', body:'{}' });
      systemCard('RESULT · Resume', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
      await loadTasks();
    } catch (e) {
      toast(`Resume failed (${e.status || 'ERR'}).`);
    }
  }

  async function taskAbort(id) {
    if (!state.adminUnlocked) { toast('Admin locked. Type: unlock admin'); return; }
    try {
      const data = await fetchJson(API.taskAbort(id), { method:'POST', body:'{}' });
      systemCard('RESULT · Abort', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
      await loadTasks();
    } catch (e) {
      toast(`Abort failed (${e.status || 'ERR'}).`);
    }
  }

  // ---------- Memory (system UI only; unchanged behavior) ----------
  async function resolveConceptsBase() {
    if (state.memoryEndpoints.conceptsBase) return state.memoryEndpoints.conceptsBase;

    for (const url of API.memoryCandidates.concepts) {
      try {
        const res = await fetch(url, { method:'GET', headers: buildHeaders() });
        if (res.status === 404) continue;
        if ([200, 401, 403, 405].includes(res.status)) {
          state.memoryEndpoints.conceptsBase = url;
          return url;
        }
      } catch {}
    }
    throw new Error('Memory concepts endpoint not found');
  }

  function normalizeConceptKey(s) {
    return String(s || '').trim().replace(/^["“”']|["“”']$/g, '').trim();
  }


  // ---------- Command normalization & pattern routing (Natural-language pressure relief) ----------
  // Deterministic, bounded: strips harmless filler so capability commands don't fall through to /advance.
  function normalizeCommandText(raw) {
    let s = String(raw || '').trim().toLowerCase();

  // Remove trailing sentence punctuation.
    s = s.replace(/[?!.…]+$/g, '').trim();

  // Collapse whitespace.
    s = s.replace(/\s+/g, ' ').trim();

  // Strip common polite lead-ins (only at the start).
    s = s.replace(/^(please|pls)\s+/, '');
    s = s.replace(/^(can you|could you|would you|will you)\s+/, '');
    s = s.replace(/^(hey|hi|hello)\s+/, '');

  // Strip light filler phrases at the start.
    s = s.replace(/^(ok|okay|alright)\s*[,:]?\s+/, '');

  // Re-collapse after removals.
    s = s.replace(/\s+/g, ' ').trim();
    return s;
  }

  function parseMemoryCommand(rawText) {
    const s = normalizeCommandText(rawText);

  // SHOW MEMORY (variants)
    if (/^show\s+(?:me\s+)?(?:my\s+)?memory$/.test(s)) return { kind: 'mem_show' };
    if (/^show\s+(?:me\s+)?memories$/.test(s)) return { kind: 'mem_show' };
    if (/^show\s+(?:me\s+)?my\s+memories$/.test(s)) return { kind: 'mem_show' };
    if (/^my\s+memories$/.test(s)) return { kind: 'mem_show' };
    if (/^what\s+do\s+you\s+remember(?:\s+about\s+me)?$/.test(s)) return { kind: 'mem_show' };
    if (/^tell\s+me\s+what\s+you\s+remember(?:\s+about\s+me)?$/.test(s)) return { kind: 'mem_show' };

  // WHO AM I (identity)
    if (/^who\s+am\s+i$/.test(s)) return { kind: 'whoami' };

  // FORGET
    // "forget key", "forget that key", "forget my favorite color"
    const f1 = s.match(/^forget\s+(?:that\s+)?(.+)$/);
    if (f1) {
      const key = normalizeConceptKey(f1[1]);
      if (key) return { kind: 'mem_forget', key };
      return { kind: 'ambiguous_forget' };
    }

  // REMEMBER (writes)
    // Preferred: key=value
    const rEq = s.match(/^remember\s+(.+?)\s*=\s*(.+)$/);
    if (rEq) {
      const key = normalizeConceptKey(rEq[1]);
      const val = String(rEq[2] || '').trim();
      if (key && val) return { kind: 'mem_write', key, val };
      return { kind: 'ambiguous_remember' };
    }

  // Natural: "remember (that )?<key> is <value>"
    const rIs = s.match(/^remember\s+(?:that\s+)?(.+?)\s+is\s+(.+)$/);
    if (rIs) {
      const key = normalizeConceptKey(rIs[1]);
      const val = String(rIs[2] || '').trim();
      if (key && val) return { kind: 'mem_write', key, val };
      return { kind: 'ambiguous_remember' };
    }

  // If it starts with "remember" but didn't match a safe pattern, treat as ambiguous command (clarify).
    if (/^remember\b/.test(s)) return { kind: 'ambiguous_remember' };

  return null;
  }

  function makeConceptPayload(conceptKey) {
    return { concept_key: conceptKey, notes: 'memory test concept', confidence: 1.0 };
  }

  async function memoryWriteConcept(conceptKey) {
    if (!state.adminUnlocked) throw new Error('Admin is locked');
    const base = await resolveConceptsBase();
    const clean = normalizeConceptKey(conceptKey);
    if (!clean) throw new Error('Concept key required');
    return await fetchJson(base, { method:'POST', body: JSON.stringify(makeConceptPayload(clean)) });
  }

  async function memoryFetchConceptObjects() {
    const base = await resolveConceptsBase();
    const data = await fetchJson(base, { method: 'GET' });

    const arr =
      Array.isArray(data) ? data :
      Array.isArray(data?.concepts) ? data.concepts :
      Array.isArray(data?.items) ? data.items :
      [];

    return arr;
  }

  async function memoryListConcepts() {
    const arr = await memoryFetchConceptObjects();
    return arr.map(x => {
      if (typeof x === 'string') return x;
      return x?.concept_key || x?.key || x?.concept || x?.name || JSON.stringify(x);
    });
  }

  async function memoryDeleteConcept(conceptKey) {
    if (!state.adminUnlocked) throw new Error('Admin is locked');
    const clean = normalizeConceptKey(conceptKey);
    if (!clean) throw new Error('Concept key required');

    const base = (await resolveConceptsBase()).replace(/\/$/, '');
    const arr = await memoryFetchConceptObjects();
    const hit = arr.find(x => x && typeof x === 'object' && String(x.concept_key || x.key || '').trim() === clean);
    if (!hit) return { ok: true, already_deleted: true };

    const id = hit.id ?? hit.concept_id ?? hit.pk;
    if (id == null) throw new Error('Memory item missing id');

    const url = `${base}/${encodeURIComponent(String(id))}`;
    return await fetchJson(url, { method: 'DELETE' });
  }

  
// ---------- Identity & Memory v1 (Tier 1: safe self-profile) ----------
async function idMe() {
  const data = await fetchJson(API.idMe, { method:'GET' });
  return data;
}

async function memV1Show() {
  const data = await fetchJson(API.memShow, { method:'GET' });
  return data;
}

async function memV1Write(key, value) {
  const body = { memory_key: String(key || '').trim(), memory_value: String(value || '').trim() };
  if (!body.memory_key || !body.memory_value) throw new Error('memory_key and memory_value required');
  return await fetchJson(API.memWrite, { method:'POST', body: JSON.stringify(body) });
}

async function memV1Forget(key) {
  const body = { memory_key: String(key || '').trim() };
  if (!body.memory_key) throw new Error('memory_key required');
  return await fetchJson(API.memForget, { method:'POST', body: JSON.stringify(body) });
}

async function adminInboxList() {
  return await fetchJson(API.adminInbox, { method:'GET' });
}

function isAffirmation(text) {
    const t = String(text || '').trim().toLowerCase();
    return ['yes','y','yep','yeah','ok','okay','confirm','do it','sure','affirmative','proceed'].includes(t);
  }
  function isNegation(text) {
    const t = String(text || '').trim().toLowerCase();
    return ['no','n','nope','nah','cancel','stop','never mind','nevermind','forget it','dont','don’t'].includes(t);
  }

  function setPending(kind, key, value) {
    state.pendingMemory = { kind, key: normalizeConceptKey(key) };
    if (value != null) state.pendingMemory.value = String(value);

    const k = state.pendingMemory.key;
    const v = (state.pendingMemory.value != null) ? String(state.pendingMemory.value) : '';
    if (!k) return;

    // Conversation-first: confirmation must appear in-chat, not as a toast.
    if (kind === 'memv1_write') {
      sayAlice(`I can remember that as: ${k} = ${v}.

Reply “yes” to confirm, or “no” to cancel.`);
    } else if (kind === 'memv1_forget') {
      sayAlice(`I can forget: ${k}.

Reply “yes” to confirm, or “no” to cancel.`);
    } else if (kind === 'write') {
      sayAlice(`I can save: ${k}.

Reply “yes” to confirm, or “no” to cancel.`);
    } else if (kind === 'delete') {
      sayAlice(`I can remove: ${k}.

Reply “yes” to confirm, or “no” to cancel.`);
    } else {
      sayAlice(`Pending action: ${k}.

Reply “yes” to confirm, or “no” to cancel.`);
    }
  }
  function clearPending() { state.pendingMemory = null; }

  async function handlePendingConfirmation(userText) {
    if (!state.pendingMemory) return false;

    if (isNegation(userText)) {
      sayAlice('Okay. Cancelled.');
      clearPending();
      return true;
    }

    if (!isAffirmation(userText)) {
      sayAlice('Reply “yes” to confirm, or “no” to cancel.');
      return true;
    }

    const { kind, key, value } = state.pendingMemory;
    clearPending();

    try {
      if (kind === 'write') {
        await memoryWriteConcept(key);
        sayAlice('Saved.');
      } else if (kind === 'delete') {
        await memoryDeleteConcept(key);
        sayAlice('Removed.');
      } else if (kind === 'memv1_write') {
        const val = String(value || '').trim();
        await memV1Write(key, val);
        sayAlice('Saved to your profile.');
      } else if (kind === 'memv1_forget') {
        await memV1Forget(key);
        sayAlice('Forgotten.');
      } else {

        throw new Error('Unknown pending action');
      }
    } catch (e) {
      sayAlice(`That didn’t work (${e.status || 'ERR'}).`);
    }

    return true;
  }

  // ---------- /ask ----------
  const ALICE_SYSTEM_PROMPT = [
    "You are Alice, the sole human-facing assistant.",
    "ISAC is the silent backend. Never mention ISAC, never identify as ISAC, and never say you are ISAC.",
    "Conversation is the authority spine. Be concise, clear, and practical.",
    "If a user asks you to remember something, ask for explicit confirmation before any memory write.",
    "If you cannot perform an action, explain why and suggest the next safe step.",
    "Emoji, if any, must be sparse and intentional."
  ].join("\n");

  // Guard against any accidental /ask bypass paths.
  // Only sendAsk() is allowed to call /ask, and only after the gate returns ADVANCE_OK.
  let ASK_ALLOWED = false;
  async function askModel(url, opts) {
    if (!ASK_ALLOWED) {
      const err = new Error('ASK_BYPASS_BLOCKED');
      err.status = 499;
      throw err;
    }
    return await fetchJson(url, opts);
  }

  async function sendAsk(text) {
    try {
      const raw = String(text || '').trim();
      if (!raw) return;

      // 1) Legitimacy gate (v2): decide whether Alice may speak.
      const gateCtx = buildCtxArrayForGate({ excludeLast: true });
      const gatePayload = { msg: raw, ctx: gateCtx, mode: 'normal', flags: {} };

      const gate = await fetchJson(API.gateAdvance, { method:'POST', body: JSON.stringify(gatePayload) });
      const decision = String(gate?.decision || '').toUpperCase().trim();
      try { console.debug('[gate]', { msg: raw, decision, reason: gate?.reason, question: gate?.question }); } catch {}
      state.lastDecision = decision || null;

      if (decision === 'RESTRAIN') {
        // v3: breathing dot resolves into static “…” after a brief human pause.
        setSubtitle('Listening.');
        await ensureMinAck(TIMING.restraintResolveMs);
        showPresence('ellipsis');
        return;
      }

      if (decision === 'CLARIFY') {
        // v3: dot disappears at expression start; exactly one question.
        const qRaw = firstQuestionOnly(String(gate?.question || '').trim()) || 'What would you like me to do with that?';
        const q = stripSpeakerPrefix(qRaw);
        setSubtitle('Alice asked a clarification.');
        await ensureMinAck();
        await new Promise(requestAnimationFrame);
        sayAlice(q);
        return;
      }

      // 2) ADVANCE_OK: ask the model for a normal reply.
      await ensureMinAck();
      const ctx = buildContextBlockForModel({ excludeLast: true });
      const composed = ctx ? (ctx + "\n\nUser: " + raw) : raw;
      const payload = { message: composed, system_prompt: ALICE_SYSTEM_PROMPT };

      ASK_ALLOWED = true;
      let data;
      try {
        data = await askModel(API.ask, { method:'POST', body: JSON.stringify(payload) });
      } finally {
        ASK_ALLOWED = false;
      }

      const replyText = stripSpeakerPrefix(String(data?.reply || data?.answer || data?.response || data?.text || '').trim());

      // Identity boundary: block any "I am ISAC" leaks.
      const leak = /\b(i\s*['’]?m|i\s*am)\s+isac\b/i.test(replyText) || /\bisac\b\s*(brain|backend)/i.test(replyText);
      if (leak) {
        systemNote('Response blocked (identity boundary).');
        return;
      }

      setSubtitle('Conversation-first. Tasks only appear when you ask.');
      await new Promise(requestAnimationFrame);
      sayAlice(replyText || '(no reply)');

      // Memory suggestion hooks (system-only confirmation loop)
      const m1 = replyText.match(/remember\s*[“"']([^”"']+)[”"']/i);
      if (m1?.[1]) setPending('write', m1[1]);

      const f1 = replyText.match(/forget\s*[“"']([^”"']+)[”"']/i);
      if (f1?.[1]) setPending('delete', f1[1]);

    } catch (e) {
      // Any error ends presence indicator (no dangling dot).
      removePresence();
      const code = e.status ? `HTTP ${e.status}` : 'ERR';
      systemNote(`Request failed (${code}).`);
      systemCard('ERROR · Request failed', `<pre>${esc(String(e.message || 'Unknown error').slice(0, 1200))}</pre>`);
      setHealth(false);
    }
  }

  // ---------- Command routing ----------
  async function handle(text) {
    const t = String(text || '').trim();
    const c = normalizeCommandText(t);
    if (state.pendingMemory) {
      const consumed = await handlePendingConfirmation(t);
      if (consumed) return;
    }

    if (c === 'show tasks' || c === 'tasks') { openTasks(); return; }

    if (c === 'who am i' || c === 'whoami' || c === 'me') {
      try {
        const data = await idMe();
        systemCard('RESULT · Identity', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
      } catch (e) {
        sayAlice(`I couldn’t read your identity (${e.status || 'ERR'}).`);
      }
      return;
    }

    if (c === 'show my memory' || c === 'show me my memory' || c === 'show memory' || c === 'show me memory' || c === 'memories') {
      try {
        const data = await memV1Show();
        systemCard('RESULT · Memory (v1)', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
      } catch (e) {
        sayAlice(`I couldn’t read your memory (${e.status || 'ERR'}).`);
      }
      return;
    }

    if (c === 'show inbox' || c === 'admin inbox') {
      if (!state.adminUnlocked) { toast('Admin locked. Type: unlock admin'); return; }
      try {
        const data = await adminInboxList();
        systemCard('RESULT · Admin inbox', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
      } catch (e) {
        toast(`Inbox read failed (${e.status || 'ERR'}).`);
      }
      return;
    }

    
    // Capability command routing (memory + identity) BEFORE /advance gating.
    // This prevents natural phrasing from being misclassified as ambient statements.
    const memCmd = parseMemoryCommand(t);
    if (memCmd) {
      if (memCmd.kind === 'mem_show') {
        try {
          const data = await memV1Show();
          systemCard('RESULT · Memory (v1)', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
        } catch (e) {
          sayAlice(`I couldn’t read your memory (${e.status || 'ERR'}).`);
        }
        return;
      }
      if (memCmd.kind === 'whoami') {
        try {
          const data = await identityWhoAmI();
          systemCard('RESULT · Identity (v1)', `<pre>${esc(JSON.stringify(data, null, 2))}</pre>`);
        } catch (e) {
          sayAlice(`I couldn’t read your identity (${e.status || 'ERR'}).`);
        }
        return;
      }
      if (memCmd.kind === 'mem_write') {
        setPending('memv1_write', memCmd.key, memCmd.val);
        return;
      }
      if (memCmd.kind === 'mem_forget') {
        setPending('memv1_forget', memCmd.key);
        return;
      }
      if (memCmd.kind === 'ambiguous_remember') {
        sayAlice('What should I remember, exactly? Use `remember key=value` or `remember <key> is <value>`.');
        return;
      }
      if (memCmd.kind === 'ambiguous_forget') {
        sayAlice('What should I forget? For example: `forget favorite color`.');
        return;
      }
    }

// v1 profile memory command: "remember key=value"
    const rem = t.match(/^remember\s+([^=:\n]+)\s*[:=]\s*(.+)$/i);
    if (rem) {
      const key = normalizeConceptKey(rem[1]);
      const val = String(rem[2] || '').trim();
      if (!key || !val) { sayAlice('Use `remember key=value` (or `remember <key> is <value>`).'); return; }
      setPending('memv1_write', key, val);
      toast('Pending save. Reply “yes” to confirm.');
      return;
    }

    // v1 profile memory command: natural language "remember KEY is VALUE"
    // Examples:
    //   remember my favorite color is blue
    //   remember that my favorite color is blue
    const rem2 = t.match(/^remember\s+(?:that\s+)?(.+?)\s+is\s+(.+)$/i);
    if (rem2) {
      const key = normalizeConceptKey(rem2[1]);
      const val = String(rem2[2] || '').trim();
      if (!key || !val) { sayAlice('Use `remember key=value` (or `remember <key> is <value>`).'); return; }
      setPending('memv1_write', key, val);
      toast('Pending save. Reply “yes” to confirm.');
      return;
    }

    // v1 profile memory command: minimal fallback "remember KEY VALUE"
    // (Only if KEY is multi-word to avoid accidental captures.)
    const rem3 = t.match(/^remember\s+(.+?)\s+([^\s]+)$/i);
    if (rem3) {
      const keyRaw = String(rem3[1] || '').trim();
      const val = String(rem3[2] || '').trim();
      if (keyRaw && keyRaw.includes(' ') && val) {
        const key = normalizeConceptKey(keyRaw);
        setPending('memv1_write', key, val);
        toast('Pending save. Reply “yes” to confirm.');
        return;
      }
    }

    // v1 profile forget: "forget key"
    const fkv1 = t.match(/^forget\s+(.+)$/i);
    if (fkv1) {
      const key = normalizeConceptKey(fkv1[1]);
      if (!key) { toast('Forget what? Provide a key.'); return; }
      setPending('memv1_forget', key);
      toast('Pending forget. Reply “yes” to confirm.');
      return;
    }

    if (c === 'unlock admin' || c === 'unlock') { showUnlockCard(); return; }
    if (c === 'lock admin' || c === 'lock') { lockAdmin(); return; }
    if (/^start over\b/i.test(t) || c === 'reset chat') {
      systemNote('Chat cleared for this session on this device.');
      clearChatSession();
      if (els.messages) els.messages.innerHTML = '';
      toast('Chat cleared.');
      return;
    }

    if (/^(list|show)\s+mem(ory|ories)\b/i.test(t) || /^what (memories|memory) do you have\b/i.test(c)) {
      try {
        const items = await memoryListConcepts();
        if (!items.length) systemNote('Memory is currently empty.');
        else systemCard('RESULT · Memories', `<pre>${esc(JSON.stringify(items, null, 2))}</pre>`);
      } catch (e) {
        sayAlice(`I couldn’t read your memory (${e.status || 'ERR'}).`);
      }
      return;
    }

    const forgetMatch = t.match(/^(forget|delete)\s+(.+)$/i);
    if (forgetMatch) {
      const key = normalizeConceptKey(forgetMatch[2]);
      if (!key) { toast('Forget what? Provide a key.'); return; }
      if (!state.adminUnlocked) { toast('Admin locked. Type: unlock admin'); return; }
      setPending('delete', key);
      toast('Pending delete. Reply “yes” to confirm.');
      return;
    }

    // Tool command routing (v4-A unified tool-call flow)
    const cmd = parseToolCommand(t);
    if (cmd) {
      try {
        await handleToolCommand(cmd, t);
      } catch (e) {
        removePresence();
        const code = e.status ? `HTTP ${e.status}` : 'ERR';
        systemNote(`Tool call failed (${code}).`);
        systemCard('ERROR · Tool call failed', `<pre>${esc(String(e.message || 'Unknown error').slice(0, 1200))}</pre>`);
        setHealth(false);
      }
      return;
    }

    await sendAsk(t);
  }

  // ---------- Input ----------
  function autosize() {
    if (!els.input) return;
    els.input.style.height = 'auto';
    els.input.style.height = Math.min(220, els.input.scrollHeight) + 'px';
  }

  function onSend() {
    const text = String(els.input?.value || '').trim();
    if (!text) return;

    els.input.value = '';
    autosize();

    // 1) User message enters transcript.
    sayMe(text);

    // 2) v3 Presence: immediate acknowledgment on input receipt.
    // Dot = engagement, not thinking.
    showPresence('breathing');
    markAckStart();

    // 3) Route command / ask.
    void handle(text);
  }

  // ---------- Boot ----------
  function boot() {
    bindEls();

    if (!els.scroll || !els.messages || !els.input || !els.sendBtn) {
      console.error('DOM missing required nodes. Expected #scroll, #messages, #input, #sendBtn');
      return;
    }

    const ok = loadAuth();
    setTasksCount(0);
    setAdminUI();

    loadChatFromSession();
    renderTranscriptFromState();

    if ((state.chat?.messages || []).length === 0) {
      systemNote('Ready.');
    }

    els.sendBtn.addEventListener('click', onSend);
    els.input.addEventListener('input', autosize);
    els.input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        onSend();
      }
    });

    els.tasksChip?.addEventListener('click', () => state.tasksOpen ? closeTasks() : openTasks());
    els.adminChip?.addEventListener('click', () => state.adminUnlocked ? lockAdmin() : showUnlockCard());

    els.closeTasksBtn?.addEventListener('click', closeTasks);
    els.refreshTasksBtn?.addEventListener('click', () => void loadTasks());
    els.tasksOverlay?.addEventListener('click', (e) => { if (e.target === els.tasksOverlay) closeTasks(); });

    els.toastClose?.addEventListener('click', () => els.toast?.classList.remove('show'));

    autosize();
    if (ok) void checkHealth();
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
  </script>
</body>
</html>